
sircd:     file format elf32-i386


Disassembly of section .init:

08048f20 <_init>:
 8048f20:	53                   	push   %ebx
 8048f21:	83 ec 08             	sub    $0x8,%esp
 8048f24:	e8 00 00 00 00       	call   8048f29 <_init+0x9>
 8048f29:	5b                   	pop    %ebx
 8048f2a:	81 c3 d7 50 00 00    	add    $0x50d7,%ebx
 8048f30:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048f36:	85 c0                	test   %eax,%eax
 8048f38:	74 05                	je     8048f3f <_init+0x1f>
 8048f3a:	e8 71 02 00 00       	call   80491b0 <__gmon_start__@plt>
 8048f3f:	e8 ec 05 00 00       	call   8049530 <frame_dummy>
 8048f44:	e8 07 28 00 00       	call   804b750 <__do_global_ctors_aux>
 8048f49:	83 c4 08             	add    $0x8,%esp
 8048f4c:	5b                   	pop    %ebx
 8048f4d:	c3                   	ret    

Disassembly of section .plt:

08048f50 <setsockopt@plt-0x10>:
 8048f50:	ff 35 04 e0 04 08    	pushl  0x804e004
 8048f56:	ff 25 08 e0 04 08    	jmp    *0x804e008
 8048f5c:	00 00                	add    %al,(%eax)
	...

08048f60 <setsockopt@plt>:
 8048f60:	ff 25 0c e0 04 08    	jmp    *0x804e00c
 8048f66:	68 00 00 00 00       	push   $0x0
 8048f6b:	e9 e0 ff ff ff       	jmp    8048f50 <_init+0x30>

08048f70 <dup2@plt>:
 8048f70:	ff 25 10 e0 04 08    	jmp    *0x804e010
 8048f76:	68 08 00 00 00       	push   $0x8
 8048f7b:	e9 d0 ff ff ff       	jmp    8048f50 <_init+0x30>

08048f80 <strstr@plt>:
 8048f80:	ff 25 14 e0 04 08    	jmp    *0x804e014
 8048f86:	68 10 00 00 00       	push   $0x10
 8048f8b:	e9 c0 ff ff ff       	jmp    8048f50 <_init+0x30>

08048f90 <read@plt>:
 8048f90:	ff 25 18 e0 04 08    	jmp    *0x804e018
 8048f96:	68 18 00 00 00       	push   $0x18
 8048f9b:	e9 b0 ff ff ff       	jmp    8048f50 <_init+0x30>

08048fa0 <pause@plt>:
 8048fa0:	ff 25 1c e0 04 08    	jmp    *0x804e01c
 8048fa6:	68 20 00 00 00       	push   $0x20
 8048fab:	e9 a0 ff ff ff       	jmp    8048f50 <_init+0x30>

08048fb0 <sem_init@plt>:
 8048fb0:	ff 25 20 e0 04 08    	jmp    *0x804e020
 8048fb6:	68 28 00 00 00       	push   $0x28
 8048fbb:	e9 90 ff ff ff       	jmp    8048f50 <_init+0x30>

08048fc0 <sigprocmask@plt>:
 8048fc0:	ff 25 24 e0 04 08    	jmp    *0x804e024
 8048fc6:	68 30 00 00 00       	push   $0x30
 8048fcb:	e9 80 ff ff ff       	jmp    8048f50 <_init+0x30>

08048fd0 <free@plt>:
 8048fd0:	ff 25 28 e0 04 08    	jmp    *0x804e028
 8048fd6:	68 38 00 00 00       	push   $0x38
 8048fdb:	e9 70 ff ff ff       	jmp    8048f50 <_init+0x30>

08048fe0 <memcpy@plt>:
 8048fe0:	ff 25 2c e0 04 08    	jmp    *0x804e02c
 8048fe6:	68 40 00 00 00       	push   $0x40
 8048feb:	e9 60 ff ff ff       	jmp    8048f50 <_init+0x30>

08048ff0 <pthread_self@plt>:
 8048ff0:	ff 25 30 e0 04 08    	jmp    *0x804e030
 8048ff6:	68 48 00 00 00       	push   $0x48
 8048ffb:	e9 50 ff ff ff       	jmp    8048f50 <_init+0x30>

08049000 <ferror@plt>:
 8049000:	ff 25 34 e0 04 08    	jmp    *0x804e034
 8049006:	68 50 00 00 00       	push   $0x50
 804900b:	e9 40 ff ff ff       	jmp    8048f50 <_init+0x30>

08049010 <fgets@plt>:
 8049010:	ff 25 38 e0 04 08    	jmp    *0x804e038
 8049016:	68 58 00 00 00       	push   $0x58
 804901b:	e9 30 ff ff ff       	jmp    8048f50 <_init+0x30>

08049020 <fclose@plt>:
 8049020:	ff 25 3c e0 04 08    	jmp    *0x804e03c
 8049026:	68 60 00 00 00       	push   $0x60
 804902b:	e9 20 ff ff ff       	jmp    8048f50 <_init+0x30>

08049030 <lseek@plt>:
 8049030:	ff 25 40 e0 04 08    	jmp    *0x804e040
 8049036:	68 68 00 00 00       	push   $0x68
 804903b:	e9 10 ff ff ff       	jmp    8048f50 <_init+0x30>

08049040 <sleep@plt>:
 8049040:	ff 25 44 e0 04 08    	jmp    *0x804e044
 8049046:	68 70 00 00 00       	push   $0x70
 804904b:	e9 00 ff ff ff       	jmp    8048f50 <_init+0x30>

08049050 <select@plt>:
 8049050:	ff 25 48 e0 04 08    	jmp    *0x804e048
 8049056:	68 78 00 00 00       	push   $0x78
 804905b:	e9 f0 fe ff ff       	jmp    8048f50 <_init+0x30>

08049060 <alarm@plt>:
 8049060:	ff 25 4c e0 04 08    	jmp    *0x804e04c
 8049066:	68 80 00 00 00       	push   $0x80
 804906b:	e9 e0 fe ff ff       	jmp    8048f50 <_init+0x30>

08049070 <recvfrom@plt>:
 8049070:	ff 25 50 e0 04 08    	jmp    *0x804e050
 8049076:	68 88 00 00 00       	push   $0x88
 804907b:	e9 d0 fe ff ff       	jmp    8048f50 <_init+0x30>

08049080 <gethostbyaddr@plt>:
 8049080:	ff 25 54 e0 04 08    	jmp    *0x804e054
 8049086:	68 90 00 00 00       	push   $0x90
 804908b:	e9 c0 fe ff ff       	jmp    8048f50 <_init+0x30>

08049090 <__stack_chk_fail@plt>:
 8049090:	ff 25 58 e0 04 08    	jmp    *0x804e058
 8049096:	68 98 00 00 00       	push   $0x98
 804909b:	e9 b0 fe ff ff       	jmp    8048f50 <_init+0x30>

080490a0 <_IO_getc@plt>:
 80490a0:	ff 25 5c e0 04 08    	jmp    *0x804e05c
 80490a6:	68 a0 00 00 00       	push   $0xa0
 80490ab:	e9 a0 fe ff ff       	jmp    8048f50 <_init+0x30>

080490b0 <getpgrp@plt>:
 80490b0:	ff 25 60 e0 04 08    	jmp    *0x804e060
 80490b6:	68 a8 00 00 00       	push   $0xa8
 80490bb:	e9 90 fe ff ff       	jmp    8048f50 <_init+0x30>

080490c0 <wait@plt>:
 80490c0:	ff 25 64 e0 04 08    	jmp    *0x804e064
 80490c6:	68 b0 00 00 00       	push   $0xb0
 80490cb:	e9 80 fe ff ff       	jmp    8048f50 <_init+0x30>

080490d0 <__fdelt_chk@plt>:
 80490d0:	ff 25 68 e0 04 08    	jmp    *0x804e068
 80490d6:	68 b8 00 00 00       	push   $0xb8
 80490db:	e9 70 fe ff ff       	jmp    8048f50 <_init+0x30>

080490e0 <sigismember@plt>:
 80490e0:	ff 25 6c e0 04 08    	jmp    *0x804e06c
 80490e6:	68 c0 00 00 00       	push   $0xc0
 80490eb:	e9 60 fe ff ff       	jmp    8048f50 <_init+0x30>

080490f0 <__xstat@plt>:
 80490f0:	ff 25 70 e0 04 08    	jmp    *0x804e070
 80490f6:	68 c8 00 00 00       	push   $0xc8
 80490fb:	e9 50 fe ff ff       	jmp    8048f50 <_init+0x30>

08049100 <perror@plt>:
 8049100:	ff 25 74 e0 04 08    	jmp    *0x804e074
 8049106:	68 d0 00 00 00       	push   $0xd0
 804910b:	e9 40 fe ff ff       	jmp    8048f50 <_init+0x30>

08049110 <accept@plt>:
 8049110:	ff 25 78 e0 04 08    	jmp    *0x804e078
 8049116:	68 d8 00 00 00       	push   $0xd8
 804911b:	e9 30 fe ff ff       	jmp    8048f50 <_init+0x30>

08049120 <fwrite@plt>:
 8049120:	ff 25 7c e0 04 08    	jmp    *0x804e07c
 8049126:	68 e0 00 00 00       	push   $0xe0
 804912b:	e9 20 fe ff ff       	jmp    8048f50 <_init+0x30>

08049130 <waitpid@plt>:
 8049130:	ff 25 80 e0 04 08    	jmp    *0x804e080
 8049136:	68 e8 00 00 00       	push   $0xe8
 804913b:	e9 10 fe ff ff       	jmp    8048f50 <_init+0x30>

08049140 <fread@plt>:
 8049140:	ff 25 84 e0 04 08    	jmp    *0x804e084
 8049146:	68 f0 00 00 00       	push   $0xf0
 804914b:	e9 00 fe ff ff       	jmp    8048f50 <_init+0x30>

08049150 <strcpy@plt>:
 8049150:	ff 25 88 e0 04 08    	jmp    *0x804e088
 8049156:	68 f8 00 00 00       	push   $0xf8
 804915b:	e9 f0 fd ff ff       	jmp    8048f50 <_init+0x30>

08049160 <realloc@plt>:
 8049160:	ff 25 8c e0 04 08    	jmp    *0x804e08c
 8049166:	68 00 01 00 00       	push   $0x100
 804916b:	e9 e0 fd ff ff       	jmp    8048f50 <_init+0x30>

08049170 <malloc@plt>:
 8049170:	ff 25 90 e0 04 08    	jmp    *0x804e090
 8049176:	68 08 01 00 00       	push   $0x108
 804917b:	e9 d0 fd ff ff       	jmp    8048f50 <_init+0x30>

08049180 <__fxstat@plt>:
 8049180:	ff 25 94 e0 04 08    	jmp    *0x804e094
 8049186:	68 10 01 00 00       	push   $0x110
 804918b:	e9 c0 fd ff ff       	jmp    8048f50 <_init+0x30>

08049190 <strerror@plt>:
 8049190:	ff 25 98 e0 04 08    	jmp    *0x804e098
 8049196:	68 18 01 00 00       	push   $0x118
 804919b:	e9 b0 fd ff ff       	jmp    8048f50 <_init+0x30>

080491a0 <__memmove_chk@plt>:
 80491a0:	ff 25 9c e0 04 08    	jmp    *0x804e09c
 80491a6:	68 20 01 00 00       	push   $0x120
 80491ab:	e9 a0 fd ff ff       	jmp    8048f50 <_init+0x30>

080491b0 <__gmon_start__@plt>:
 80491b0:	ff 25 a0 e0 04 08    	jmp    *0x804e0a0
 80491b6:	68 28 01 00 00       	push   $0x128
 80491bb:	e9 90 fd ff ff       	jmp    8048f50 <_init+0x30>

080491c0 <__h_errno_location@plt>:
 80491c0:	ff 25 a4 e0 04 08    	jmp    *0x804e0a4
 80491c6:	68 30 01 00 00       	push   $0x130
 80491cb:	e9 80 fd ff ff       	jmp    8048f50 <_init+0x30>

080491d0 <exit@plt>:
 80491d0:	ff 25 a8 e0 04 08    	jmp    *0x804e0a8
 80491d6:	68 38 01 00 00       	push   $0x138
 80491db:	e9 70 fd ff ff       	jmp    8048f50 <_init+0x30>

080491e0 <pthread_once@plt>:
 80491e0:	ff 25 ac e0 04 08    	jmp    *0x804e0ac
 80491e6:	68 40 01 00 00       	push   $0x140
 80491eb:	e9 60 fd ff ff       	jmp    8048f50 <_init+0x30>

080491f0 <kill@plt>:
 80491f0:	ff 25 b0 e0 04 08    	jmp    *0x804e0b0
 80491f6:	68 48 01 00 00       	push   $0x148
 80491fb:	e9 50 fd ff ff       	jmp    8048f50 <_init+0x30>

08049200 <open@plt>:
 8049200:	ff 25 b4 e0 04 08    	jmp    *0x804e0b4
 8049206:	68 50 01 00 00       	push   $0x150
 804920b:	e9 40 fd ff ff       	jmp    8048f50 <_init+0x30>

08049210 <fdopen@plt>:
 8049210:	ff 25 b8 e0 04 08    	jmp    *0x804e0b8
 8049216:	68 58 01 00 00       	push   $0x158
 804921b:	e9 30 fd ff ff       	jmp    8048f50 <_init+0x30>

08049220 <strtoul@plt>:
 8049220:	ff 25 bc e0 04 08    	jmp    *0x804e0bc
 8049226:	68 60 01 00 00       	push   $0x160
 804922b:	e9 20 fd ff ff       	jmp    8048f50 <_init+0x30>

08049230 <mmap@plt>:
 8049230:	ff 25 c0 e0 04 08    	jmp    *0x804e0c0
 8049236:	68 68 01 00 00       	push   $0x168
 804923b:	e9 10 fd ff ff       	jmp    8048f50 <_init+0x30>

08049240 <strchr@plt>:
 8049240:	ff 25 c4 e0 04 08    	jmp    *0x804e0c4
 8049246:	68 70 01 00 00       	push   $0x170
 804924b:	e9 00 fd ff ff       	jmp    8048f50 <_init+0x30>

08049250 <strlen@plt>:
 8049250:	ff 25 c8 e0 04 08    	jmp    *0x804e0c8
 8049256:	68 78 01 00 00       	push   $0x178
 804925b:	e9 f0 fc ff ff       	jmp    8048f50 <_init+0x30>

08049260 <sem_wait@plt>:
 8049260:	ff 25 cc e0 04 08    	jmp    *0x804e0cc
 8049266:	68 80 01 00 00       	push   $0x180
 804926b:	e9 e0 fc ff ff       	jmp    8048f50 <_init+0x30>

08049270 <__libc_start_main@plt>:
 8049270:	ff 25 d0 e0 04 08    	jmp    *0x804e0d0
 8049276:	68 88 01 00 00       	push   $0x188
 804927b:	e9 d0 fc ff ff       	jmp    8048f50 <_init+0x30>

08049280 <execve@plt>:
 8049280:	ff 25 d4 e0 04 08    	jmp    *0x804e0d4
 8049286:	68 90 01 00 00       	push   $0x190
 804928b:	e9 c0 fc ff ff       	jmp    8048f50 <_init+0x30>

08049290 <write@plt>:
 8049290:	ff 25 d8 e0 04 08    	jmp    *0x804e0d8
 8049296:	68 98 01 00 00       	push   $0x198
 804929b:	e9 b0 fc ff ff       	jmp    8048f50 <_init+0x30>

080492a0 <sigdelset@plt>:
 80492a0:	ff 25 dc e0 04 08    	jmp    *0x804e0dc
 80492a6:	68 a0 01 00 00       	push   $0x1a0
 80492ab:	e9 a0 fc ff ff       	jmp    8048f50 <_init+0x30>

080492b0 <getopt@plt>:
 80492b0:	ff 25 e0 e0 04 08    	jmp    *0x804e0e0
 80492b6:	68 a8 01 00 00       	push   $0x1a8
 80492bb:	e9 90 fc ff ff       	jmp    8048f50 <_init+0x30>

080492c0 <sem_post@plt>:
 80492c0:	ff 25 e4 e0 04 08    	jmp    *0x804e0e4
 80492c6:	68 b0 01 00 00       	push   $0x1b0
 80492cb:	e9 80 fc ff ff       	jmp    8048f50 <_init+0x30>

080492d0 <sigaddset@plt>:
 80492d0:	ff 25 e8 e0 04 08    	jmp    *0x804e0e8
 80492d6:	68 b8 01 00 00       	push   $0x1b8
 80492db:	e9 70 fc ff ff       	jmp    8048f50 <_init+0x30>

080492e0 <bind@plt>:
 80492e0:	ff 25 ec e0 04 08    	jmp    *0x804e0ec
 80492e6:	68 c0 01 00 00       	push   $0x1c0
 80492eb:	e9 60 fc ff ff       	jmp    8048f50 <_init+0x30>

080492f0 <sigfillset@plt>:
 80492f0:	ff 25 f0 e0 04 08    	jmp    *0x804e0f0
 80492f6:	68 c8 01 00 00       	push   $0x1c8
 80492fb:	e9 50 fc ff ff       	jmp    8048f50 <_init+0x30>

08049300 <__isoc99_sscanf@plt>:
 8049300:	ff 25 f4 e0 04 08    	jmp    *0x804e0f4
 8049306:	68 d0 01 00 00       	push   $0x1d0
 804930b:	e9 40 fc ff ff       	jmp    8048f50 <_init+0x30>

08049310 <fopen@plt>:
 8049310:	ff 25 f8 e0 04 08    	jmp    *0x804e0f8
 8049316:	68 d8 01 00 00       	push   $0x1d8
 804931b:	e9 30 fc ff ff       	jmp    8048f50 <_init+0x30>

08049320 <__errno_location@plt>:
 8049320:	ff 25 fc e0 04 08    	jmp    *0x804e0fc
 8049326:	68 e0 01 00 00       	push   $0x1e0
 804932b:	e9 20 fc ff ff       	jmp    8048f50 <_init+0x30>

08049330 <pthread_cancel@plt>:
 8049330:	ff 25 00 e1 04 08    	jmp    *0x804e100
 8049336:	68 e8 01 00 00       	push   $0x1e8
 804933b:	e9 10 fc ff ff       	jmp    8048f50 <_init+0x30>

08049340 <pthread_exit@plt>:
 8049340:	ff 25 04 e1 04 08    	jmp    *0x804e104
 8049346:	68 f0 01 00 00       	push   $0x1f0
 804934b:	e9 00 fc ff ff       	jmp    8048f50 <_init+0x30>

08049350 <__printf_chk@plt>:
 8049350:	ff 25 08 e1 04 08    	jmp    *0x804e108
 8049356:	68 f8 01 00 00       	push   $0x1f8
 804935b:	e9 f0 fb ff ff       	jmp    8048f50 <_init+0x30>

08049360 <sendto@plt>:
 8049360:	ff 25 0c e1 04 08    	jmp    *0x804e10c
 8049366:	68 00 02 00 00       	push   $0x200
 804936b:	e9 e0 fb ff ff       	jmp    8048f50 <_init+0x30>

08049370 <munmap@plt>:
 8049370:	ff 25 10 e1 04 08    	jmp    *0x804e110
 8049376:	68 08 02 00 00       	push   $0x208
 804937b:	e9 d0 fb ff ff       	jmp    8048f50 <_init+0x30>

08049380 <fork@plt>:
 8049380:	ff 25 14 e1 04 08    	jmp    *0x804e114
 8049386:	68 10 02 00 00       	push   $0x210
 804938b:	e9 c0 fb ff ff       	jmp    8048f50 <_init+0x30>

08049390 <sigemptyset@plt>:
 8049390:	ff 25 18 e1 04 08    	jmp    *0x804e118
 8049396:	68 18 02 00 00       	push   $0x218
 804939b:	e9 b0 fb ff ff       	jmp    8048f50 <_init+0x30>

080493a0 <listen@plt>:
 80493a0:	ff 25 1c e1 04 08    	jmp    *0x804e11c
 80493a6:	68 20 02 00 00       	push   $0x220
 80493ab:	e9 a0 fb ff ff       	jmp    8048f50 <_init+0x30>

080493b0 <setpgid@plt>:
 80493b0:	ff 25 20 e1 04 08    	jmp    *0x804e120
 80493b6:	68 28 02 00 00       	push   $0x228
 80493bb:	e9 90 fb ff ff       	jmp    8048f50 <_init+0x30>

080493c0 <pthread_join@plt>:
 80493c0:	ff 25 24 e1 04 08    	jmp    *0x804e124
 80493c6:	68 30 02 00 00       	push   $0x230
 80493cb:	e9 80 fb ff ff       	jmp    8048f50 <_init+0x30>

080493d0 <socket@plt>:
 80493d0:	ff 25 28 e1 04 08    	jmp    *0x804e128
 80493d6:	68 38 02 00 00       	push   $0x238
 80493db:	e9 70 fb ff ff       	jmp    8048f50 <_init+0x30>

080493e0 <__fprintf_chk@plt>:
 80493e0:	ff 25 2c e1 04 08    	jmp    *0x804e12c
 80493e6:	68 40 02 00 00       	push   $0x240
 80493eb:	e9 60 fb ff ff       	jmp    8048f50 <_init+0x30>

080493f0 <pthread_create@plt>:
 80493f0:	ff 25 30 e1 04 08    	jmp    *0x804e130
 80493f6:	68 48 02 00 00       	push   $0x248
 80493fb:	e9 50 fb ff ff       	jmp    8048f50 <_init+0x30>

08049400 <sigaction@plt>:
 8049400:	ff 25 34 e1 04 08    	jmp    *0x804e134
 8049406:	68 50 02 00 00       	push   $0x250
 804940b:	e9 40 fb ff ff       	jmp    8048f50 <_init+0x30>

08049410 <pthread_detach@plt>:
 8049410:	ff 25 38 e1 04 08    	jmp    *0x804e138
 8049416:	68 58 02 00 00       	push   $0x258
 804941b:	e9 30 fb ff ff       	jmp    8048f50 <_init+0x30>

08049420 <gethostbyname@plt>:
 8049420:	ff 25 3c e1 04 08    	jmp    *0x804e13c
 8049426:	68 60 02 00 00       	push   $0x260
 804942b:	e9 20 fb ff ff       	jmp    8048f50 <_init+0x30>

08049430 <strtol@plt>:
 8049430:	ff 25 40 e1 04 08    	jmp    *0x804e140
 8049436:	68 68 02 00 00       	push   $0x268
 804943b:	e9 10 fb ff ff       	jmp    8048f50 <_init+0x30>

08049440 <fputs@plt>:
 8049440:	ff 25 44 e1 04 08    	jmp    *0x804e144
 8049446:	68 70 02 00 00       	push   $0x270
 804944b:	e9 00 fb ff ff       	jmp    8048f50 <_init+0x30>

08049450 <connect@plt>:
 8049450:	ff 25 48 e1 04 08    	jmp    *0x804e148
 8049456:	68 78 02 00 00       	push   $0x278
 804945b:	e9 f0 fa ff ff       	jmp    8048f50 <_init+0x30>

08049460 <close@plt>:
 8049460:	ff 25 4c e1 04 08    	jmp    *0x804e14c
 8049466:	68 80 02 00 00       	push   $0x280
 804946b:	e9 e0 fa ff ff       	jmp    8048f50 <_init+0x30>

08049470 <__ctype_b_loc@plt>:
 8049470:	ff 25 50 e1 04 08    	jmp    *0x804e150
 8049476:	68 88 02 00 00       	push   $0x288
 804947b:	e9 d0 fa ff ff       	jmp    8048f50 <_init+0x30>

08049480 <calloc@plt>:
 8049480:	ff 25 54 e1 04 08    	jmp    *0x804e154
 8049486:	68 90 02 00 00       	push   $0x290
 804948b:	e9 c0 fa ff ff       	jmp    8048f50 <_init+0x30>

08049490 <__sprintf_chk@plt>:
 8049490:	ff 25 58 e1 04 08    	jmp    *0x804e158
 8049496:	68 98 02 00 00       	push   $0x298
 804949b:	e9 b0 fa ff ff       	jmp    8048f50 <_init+0x30>

Disassembly of section .text:

080494a0 <_start>:
 80494a0:	31 ed                	xor    %ebp,%ebp
 80494a2:	5e                   	pop    %esi
 80494a3:	89 e1                	mov    %esp,%ecx
 80494a5:	83 e4 f0             	and    $0xfffffff0,%esp
 80494a8:	50                   	push   %eax
 80494a9:	54                   	push   %esp
 80494aa:	52                   	push   %edx
 80494ab:	68 40 b7 04 08       	push   $0x804b740
 80494b0:	68 d0 b6 04 08       	push   $0x804b6d0
 80494b5:	51                   	push   %ecx
 80494b6:	56                   	push   %esi
 80494b7:	68 80 9b 04 08       	push   $0x8049b80
 80494bc:	e8 af fd ff ff       	call   8049270 <__libc_start_main@plt>
 80494c1:	f4                   	hlt    
 80494c2:	66 90                	xchg   %ax,%ax
 80494c4:	66 90                	xchg   %ax,%ax
 80494c6:	66 90                	xchg   %ax,%ax
 80494c8:	66 90                	xchg   %ax,%ax
 80494ca:	66 90                	xchg   %ax,%ax
 80494cc:	66 90                	xchg   %ax,%ax
 80494ce:	66 90                	xchg   %ax,%ax

080494d0 <__do_global_dtors_aux>:
 80494d0:	55                   	push   %ebp
 80494d1:	89 e5                	mov    %esp,%ebp
 80494d3:	53                   	push   %ebx
 80494d4:	83 ec 04             	sub    $0x4,%esp
 80494d7:	80 3d 90 e1 04 08 00 	cmpb   $0x0,0x804e190
 80494de:	75 3f                	jne    804951f <__do_global_dtors_aux+0x4f>
 80494e0:	a1 94 e1 04 08       	mov    0x804e194,%eax
 80494e5:	bb 24 df 04 08       	mov    $0x804df24,%ebx
 80494ea:	81 eb 20 df 04 08    	sub    $0x804df20,%ebx
 80494f0:	c1 fb 02             	sar    $0x2,%ebx
 80494f3:	83 eb 01             	sub    $0x1,%ebx
 80494f6:	39 d8                	cmp    %ebx,%eax
 80494f8:	73 1e                	jae    8049518 <__do_global_dtors_aux+0x48>
 80494fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049500:	83 c0 01             	add    $0x1,%eax
 8049503:	a3 94 e1 04 08       	mov    %eax,0x804e194
 8049508:	ff 14 85 20 df 04 08 	call   *0x804df20(,%eax,4)
 804950f:	a1 94 e1 04 08       	mov    0x804e194,%eax
 8049514:	39 d8                	cmp    %ebx,%eax
 8049516:	72 e8                	jb     8049500 <__do_global_dtors_aux+0x30>
 8049518:	c6 05 90 e1 04 08 01 	movb   $0x1,0x804e190
 804951f:	83 c4 04             	add    $0x4,%esp
 8049522:	5b                   	pop    %ebx
 8049523:	5d                   	pop    %ebp
 8049524:	c3                   	ret    
 8049525:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049530 <frame_dummy>:
 8049530:	55                   	push   %ebp
 8049531:	89 e5                	mov    %esp,%ebp
 8049533:	83 ec 18             	sub    $0x18,%esp
 8049536:	a1 28 df 04 08       	mov    0x804df28,%eax
 804953b:	85 c0                	test   %eax,%eax
 804953d:	74 12                	je     8049551 <frame_dummy+0x21>
 804953f:	b8 00 00 00 00       	mov    $0x0,%eax
 8049544:	85 c0                	test   %eax,%eax
 8049546:	74 09                	je     8049551 <frame_dummy+0x21>
 8049548:	c7 04 24 28 df 04 08 	movl   $0x804df28,(%esp)
 804954f:	ff d0                	call   *%eax
 8049551:	c9                   	leave  
 8049552:	c3                   	ret    
 8049553:	66 90                	xchg   %ax,%ax
 8049555:	66 90                	xchg   %ax,%ax
 8049557:	66 90                	xchg   %ax,%ax
 8049559:	66 90                	xchg   %ax,%ax
 804955b:	66 90                	xchg   %ax,%ax
 804955d:	66 90                	xchg   %ax,%ax
 804955f:	90                   	nop

08049560 <tokenize>:
 * determine what action to take next.
 *
 * Returns the number of tokens parsed.
 */
int tokenize( char const *in_buf, char tokens[MAX_MSG_TOKENS][MAX_MSG_LEN+1] )
{
 8049560:	55                   	push   %ebp
 8049561:	89 e5                	mov    %esp,%ebp
 8049563:	57                   	push   %edi
 8049564:	56                   	push   %esi
 8049565:	53                   	push   %ebx
 8049566:	31 db                	xor    %ebx,%ebx
 8049568:	83 ec 2c             	sub    $0x2c,%esp
 804956b:	8b 7d 08             	mov    0x8(%ebp),%edi
 804956e:	66 90                	xchg   %ax,%ax
    const char *current = in_buf;
    int  done = 0;

    /* Possible Bug: handling of too many args */
    while (!done && (i<MAX_MSG_TOKENS)) {
        char *next = strchr(current, ' ');
 8049570:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
 8049577:	00 
 8049578:	89 3c 24             	mov    %edi,(%esp)
 804957b:	e8 c0 fc ff ff       	call   8049240 <strchr@plt>

	if (next) {
 8049580:	85 c0                	test   %eax,%eax
    const char *current = in_buf;
    int  done = 0;

    /* Possible Bug: handling of too many args */
    while (!done && (i<MAX_MSG_TOKENS)) {
        char *next = strchr(current, ' ');
 8049582:	89 c6                	mov    %eax,%esi

	if (next) {
 8049584:	74 42                	je     80495c8 <tokenize+0x68>
	    memcpy(tokens[i], current, next-current);
 8049586:	89 da                	mov    %ebx,%edx
 8049588:	89 c1                	mov    %eax,%ecx
 804958a:	c1 e2 09             	shl    $0x9,%edx
 804958d:	29 f9                	sub    %edi,%ecx
 804958f:	01 da                	add    %ebx,%edx
	    tokens[i][next-current] = '\0';
	    current = next + 1;   /* move over the space */
	    ++i;
 8049591:	83 c3 01             	add    $0x1,%ebx
    /* Possible Bug: handling of too many args */
    while (!done && (i<MAX_MSG_TOKENS)) {
        char *next = strchr(current, ' ');

	if (next) {
	    memcpy(tokens[i], current, next-current);
 8049594:	03 55 0c             	add    0xc(%ebp),%edx

__extern_always_inline void *
__NTH (memcpy (void *__restrict __dest, __const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 8049597:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804959b:	89 7c 24 04          	mov    %edi,0x4(%esp)
	    tokens[i][next-current] = '\0';
	    current = next + 1;   /* move over the space */
 804959f:	8d 7e 01             	lea    0x1(%esi),%edi
 80495a2:	89 14 24             	mov    %edx,(%esp)
 80495a5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 80495a8:	89 4d e0             	mov    %ecx,-0x20(%ebp)
 80495ab:	e8 30 fa ff ff       	call   8048fe0 <memcpy@plt>
    while (!done && (i<MAX_MSG_TOKENS)) {
        char *next = strchr(current, ' ');

	if (next) {
	    memcpy(tokens[i], current, next-current);
	    tokens[i][next-current] = '\0';
 80495b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 80495b3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
 80495b6:	c6 04 0a 00          	movb   $0x0,(%edx,%ecx,1)
	    current = next + 1;   /* move over the space */
	    ++i;

	    /* trailing token */
	    if (*current == ':') {
 80495ba:	80 7e 01 3a          	cmpb   $0x3a,0x1(%esi)
 80495be:	74 30                	je     80495f0 <tokenize+0x90>
    int i = 0;
    const char *current = in_buf;
    int  done = 0;

    /* Possible Bug: handling of too many args */
    while (!done && (i<MAX_MSG_TOKENS)) {
 80495c0:	83 fb 09             	cmp    $0x9,%ebx
 80495c3:	7e ab                	jle    8049570 <tokenize+0x10>
 80495c5:	eb 1a                	jmp    80495e1 <tokenize+0x81>
 80495c7:	90                   	nop
#endif

__extern_always_inline char *
__NTH (strcpy (char *__restrict __dest, __const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
 80495c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
 80495cc:	89 d8                	mov    %ebx,%eax
 80495ce:	c1 e0 09             	shl    $0x9,%eax
 80495d1:	01 d8                	add    %ebx,%eax
		++i;
		done = 1;
	    }
	} else {
	    strcpy(tokens[i], current);
	    ++i;
 80495d3:	83 c3 01             	add    $0x1,%ebx
 80495d6:	03 45 0c             	add    0xc(%ebp),%eax
 80495d9:	89 04 24             	mov    %eax,(%esp)
 80495dc:	e8 6f fb ff ff       	call   8049150 <strcpy@plt>
	    done = 1;
	}
    }

    return i;
}
 80495e1:	83 c4 2c             	add    $0x2c,%esp
 80495e4:	89 d8                	mov    %ebx,%eax
 80495e6:	5b                   	pop    %ebx
 80495e7:	5e                   	pop    %esi
 80495e8:	5f                   	pop    %edi
 80495e9:	5d                   	pop    %ebp
 80495ea:	c3                   	ret    
 80495eb:	90                   	nop
 80495ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80495f0:	83 c6 02             	add    $0x2,%esi
 80495f3:	89 74 24 04          	mov    %esi,0x4(%esp)
 80495f7:	eb d3                	jmp    80495cc <tokenize+0x6c>
 80495f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049600 <get_msg>:
 * large as buf to prevent overflow.
 *
 * Returns the size of the message copied to msg.
 */
size_t get_msg(char *buf, char *msg)
{
 8049600:	55                   	push   %ebp
 8049601:	89 e5                	mov    %esp,%ebp
 8049603:	83 ec 38             	sub    $0x38,%esp
 8049606:	89 5d f4             	mov    %ebx,-0xc(%ebp)
 8049609:	8b 5d 08             	mov    0x8(%ebp),%ebx
    char *end;
    int  len;

    /* Find end of message */
    end = strstr(buf, "\r\n");
 804960c:	c7 44 24 04 a0 b7 04 	movl   $0x804b7a0,0x4(%esp)
 8049613:	08 
 * large as buf to prevent overflow.
 *
 * Returns the size of the message copied to msg.
 */
size_t get_msg(char *buf, char *msg)
{
 8049614:	89 7d fc             	mov    %edi,-0x4(%ebp)
 8049617:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804961a:	89 75 f8             	mov    %esi,-0x8(%ebp)
    char *end;
    int  len;

    /* Find end of message */
    end = strstr(buf, "\r\n");
 804961d:	89 1c 24             	mov    %ebx,(%esp)
 8049620:	e8 5b f9 ff ff       	call   8048f80 <strstr@plt>

    if( end )
 8049625:	85 c0                	test   %eax,%eax
 8049627:	74 37                	je     8049660 <get_msg+0x60>
    {
        len = end - buf + 2;
 8049629:	89 c2                	mov    %eax,%edx
 804962b:	29 d8                	sub    %ebx,%eax
 804962d:	8d 70 02             	lea    0x2(%eax),%esi

__extern_always_inline void *
__NTH (memcpy (void *__restrict __dest, __const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 8049630:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8049633:	89 74 24 08          	mov    %esi,0x8(%esp)
 8049637:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804963b:	89 3c 24             	mov    %edi,(%esp)
 804963e:	e8 9d f9 ff ff       	call   8048fe0 <memcpy@plt>
	    return -1;
    }

    /* found a complete message */
    memcpy(msg, buf, len);
    msg[end-buf] = '\0';
 8049643:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049646:	29 da                	sub    %ebx,%edx
 8049648:	c6 04 17 00          	movb   $0x0,(%edi,%edx,1)

    return len;	
}
 804964c:	89 f0                	mov    %esi,%eax
 804964e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 8049651:	8b 75 f8             	mov    -0x8(%ebp),%esi
 8049654:	8b 7d fc             	mov    -0x4(%ebp),%edi
 8049657:	89 ec                	mov    %ebp,%esp
 8049659:	5d                   	pop    %ebp
 804965a:	c3                   	ret    
 804965b:	90                   	nop
 804965c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        len = end - buf + 2;
    }
    else
    {
        /* Could not find \r\n, try searching only for \n */
        end = strstr(buf, "\n");
 8049660:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
 8049667:	00 
	if( end )
 8049668:	be ff ff ff ff       	mov    $0xffffffff,%esi
        len = end - buf + 2;
    }
    else
    {
        /* Could not find \r\n, try searching only for \n */
        end = strstr(buf, "\n");
 804966d:	89 1c 24             	mov    %ebx,(%esp)
 8049670:	e8 cb fb ff ff       	call   8049240 <strchr@plt>
	if( end )
 8049675:	85 c0                	test   %eax,%eax
 8049677:	74 d3                	je     804964c <get_msg+0x4c>
	    len = end - buf + 1;
 8049679:	89 c2                	mov    %eax,%edx
 804967b:	29 d8                	sub    %ebx,%eax
 804967d:	8d 70 01             	lea    0x1(%eax),%esi
 8049680:	eb ae                	jmp    8049630 <get_msg+0x30>
 8049682:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049690 <init_pool>:
}
/**
 * void init_pool(int listenfd, pool* p)
 * Initialize the client pool, set the listenfd as the maximum descriptor
 */
void init_pool(int listenfd, pool* p ){
 8049690:	55                   	push   %ebp
    int i;
    p->maxindex = EMPTY_FD;
 8049691:	31 c0                	xor    %eax,%eax
}
/**
 * void init_pool(int listenfd, pool* p)
 * Initialize the client pool, set the listenfd as the maximum descriptor
 */
void init_pool(int listenfd, pool* p ){
 8049693:	89 e5                	mov    %esp,%ebp
 8049695:	57                   	push   %edi
 8049696:	56                   	push   %esi
 8049697:	53                   	push   %ebx
 8049698:	83 ec 1c             	sub    $0x1c,%esp
 804969b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
 804969e:	8b 75 08             	mov    0x8(%ebp),%esi
    int i;
    p->maxindex = EMPTY_FD;
 80496a1:	c7 83 88 01 00 00 ff 	movl   $0xffffffff,0x188(%ebx)
 80496a8:	ff ff ff 
 80496ab:	90                   	nop
 80496ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    for(i = 0; i < FD_SETSIZE; i++){
        p->clientfd[i] = EMPTY_FD;
 80496b0:	c7 84 83 8c 01 00 00 	movl   $0xffffffff,0x18c(%ebx,%eax,4)
 80496b7:	ff ff ff ff 
 * Initialize the client pool, set the listenfd as the maximum descriptor
 */
void init_pool(int listenfd, pool* p ){
    int i;
    p->maxindex = EMPTY_FD;
    for(i = 0; i < FD_SETSIZE; i++){
 80496bb:	83 c0 01             	add    $0x1,%eax
 80496be:	3d 00 04 00 00       	cmp    $0x400,%eax
 80496c3:	75 eb                	jne    80496b0 <init_pool+0x20>
        p->clientfd[i] = EMPTY_FD;
    }
    p->maxfd = listenfd;
 80496c5:	89 33                	mov    %esi,(%ebx)
    FD_ZERO(&p->read_set);
 80496c7:	8d 7b 04             	lea    0x4(%ebx),%edi
 80496ca:	b9 20 00 00 00       	mov    $0x20,%ecx
 80496cf:	66 31 c0             	xor    %ax,%ax
 80496d2:	fc                   	cld    
 80496d3:	f3 ab                	rep stos %eax,%es:(%edi)
    
    FD_SET(listenfd, &p->read_set);
 80496d5:	89 34 24             	mov    %esi,(%esp)
 80496d8:	e8 f3 f9 ff ff       	call   80490d0 <__fdelt_chk@plt>
 80496dd:	89 f2                	mov    %esi,%edx
 80496df:	c1 fa 1f             	sar    $0x1f,%edx
 80496e2:	c1 ea 1b             	shr    $0x1b,%edx
 80496e5:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
 80496e8:	83 e1 1f             	and    $0x1f,%ecx
 80496eb:	29 d1                	sub    %edx,%ecx
 80496ed:	ba 01 00 00 00       	mov    $0x1,%edx
 80496f2:	d3 e2                	shl    %cl,%edx
 80496f4:	09 54 83 04          	or     %edx,0x4(%ebx,%eax,4)

}
 80496f8:	83 c4 1c             	add    $0x1c,%esp
 80496fb:	5b                   	pop    %ebx
 80496fc:	5e                   	pop    %esi
 80496fd:	5f                   	pop    %edi
 80496fe:	5d                   	pop    %ebp
 80496ff:	c3                   	ret    

08049700 <dump_pool>:
/**
 * void dump_pool(pool* p)
 * dump the member variables and the client list of the pool. 
 * mainly for debug use
 */
void dump_pool(pool* p){
 8049700:	55                   	push   %ebp
 8049701:	89 e5                	mov    %esp,%ebp
 8049703:	56                   	push   %esi
 8049704:	53                   	push   %ebx
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
 8049705:	31 db                	xor    %ebx,%ebx
 8049707:	83 ec 20             	sub    $0x20,%esp
 804970a:	8b 75 08             	mov    0x8(%ebp),%esi
 804970d:	8b 86 88 01 00 00    	mov    0x188(%esi),%eax
 8049713:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049717:	8b 86 84 01 00 00    	mov    0x184(%esi),%eax
 804971d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049721:	8b 06                	mov    (%esi),%eax
 8049723:	c7 44 24 04 fc b7 04 	movl   $0x804b7fc,0x4(%esp)
 804972a:	08 
 804972b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049732:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049736:	e8 15 fc ff ff       	call   8049350 <__printf_chk@plt>
 804973b:	c7 44 24 04 a3 b7 04 	movl   $0x804b7a3,0x4(%esp)
 8049742:	08 
 8049743:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804974a:	e8 01 fc ff ff       	call   8049350 <__printf_chk@plt>
 804974f:	eb 12                	jmp    8049763 <dump_pool+0x63>
 8049751:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    printf("Largest descriptor : %d\t Number of ready clients : %d\tMax index of ready client : %d\n",
           p->maxfd,p->nready,p->maxindex);
    int i;
    printf("Client\tdescriptor\n");
    for(i = 0; i < FD_SETSIZE; i++){
 8049758:	83 c3 01             	add    $0x1,%ebx
 804975b:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
 8049761:	74 2d                	je     8049790 <dump_pool+0x90>
 8049763:	8b 84 9e 8c 01 00 00 	mov    0x18c(%esi,%ebx,4),%eax
 804976a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 804976e:	c7 44 24 04 b6 b7 04 	movl   $0x804b7b6,0x4(%esp)
 8049775:	08 
 8049776:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804977d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049781:	e8 ca fb ff ff       	call   8049350 <__printf_chk@plt>
        printf("%6d\t %6d\n",i,p->clientfd[i] );
        if(p->clientfd[i]==EMPTY_FD){
 8049786:	83 bc 9e 8c 01 00 00 	cmpl   $0xffffffff,0x18c(%esi,%ebx,4)
 804978d:	ff 
 804978e:	75 c8                	jne    8049758 <dump_pool+0x58>
            break;
        }
    }


}
 8049790:	83 c4 20             	add    $0x20,%esp
 8049793:	5b                   	pop    %ebx
 8049794:	5e                   	pop    %esi
 8049795:	5d                   	pop    %ebp
 8049796:	c3                   	ret    
 8049797:	89 f6                	mov    %esi,%esi
 8049799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080497a0 <echo_client>:
/**
 * void echo_client(pool* p)
 * Echo a text line for each client
 */
void echo_client(pool* p){
 80497a0:	55                   	push   %ebp
 80497a1:	89 e5                	mov    %esp,%ebp
 80497a3:	57                   	push   %edi
 80497a4:	56                   	push   %esi
 80497a5:	53                   	push   %ebx
 80497a6:	81 ec 5c 25 00 00    	sub    $0x255c,%esp
 80497ac:	8b 75 08             	mov    0x8(%ebp),%esi
 80497af:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80497b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80497b8:	31 c0                	xor    %eax,%eax
    int i,connfd,n;
    rio_t rio;
    char buf[MAX_LINE_LEN];
    dump_pool(p);
 80497ba:	89 34 24             	mov    %esi,(%esp)
 80497bd:	e8 3e ff ff ff       	call   8049700 <dump_pool>
    for(i = 0; (i <= p->maxindex)&&(p->nready>0); i++){
 80497c2:	8b 8e 88 01 00 00    	mov    0x188(%esi),%ecx
 80497c8:	85 c9                	test   %ecx,%ecx
 80497ca:	0f 88 98 01 00 00    	js     8049968 <echo_client+0x1c8>
 80497d0:	8b 96 84 01 00 00    	mov    0x184(%esi),%edx
 80497d6:	85 d2                	test   %edx,%edx
 80497d8:	0f 8e 8a 01 00 00    	jle    8049968 <echo_client+0x1c8>
 80497de:	89 b5 c4 da ff ff    	mov    %esi,-0x253c(%ebp)
 80497e4:	31 ff                	xor    %edi,%edi
 80497e6:	e9 9c 00 00 00       	jmp    8049887 <echo_client+0xe7>
 80497eb:	90                   	nop
 80497ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
        rio = p->client_read_buf[i];
        if(FD_ISSET(connfd, &p->ready_set)&&(connfd > 0)){

            if((n = Rio_readlineb(&rio,buf,MAX_LINE_LEN))!=0){
                char msg[MAX_MSG_LEN];
                get_msg(buf,msg);
 80497f0:	8d 95 e4 fe ff ff    	lea    -0x11c(%ebp),%edx
 80497f6:	8d 85 e4 fc ff ff    	lea    -0x31c(%ebp),%eax
 80497fc:	89 14 24             	mov    %edx,(%esp)
 80497ff:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049803:	e8 f8 fd ff ff       	call   8049600 <get_msg>

#ifdef __va_arg_pack
__extern_always_inline int
__NTH (sprintf (char *__restrict __s, __const char *__restrict __fmt, ...))
{
  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
 8049808:	8d 95 e3 fa ff ff    	lea    -0x51d(%ebp),%edx
 804980e:	8d 85 e4 fc ff ff    	lea    -0x31c(%ebp),%eax
 8049814:	89 14 24             	mov    %edx,(%esp)
 8049817:	89 44 24 10          	mov    %eax,0x10(%esp)
 804981b:	c7 44 24 0c 56 bc 04 	movl   $0x804bc56,0xc(%esp)
 8049822:	08 
 8049823:	c7 44 24 08 01 02 00 	movl   $0x201,0x8(%esp)
 804982a:	00 
 804982b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8049832:	00 
 8049833:	e8 58 fc ff ff       	call   8049490 <__sprintf_chk@plt>
                char echomsg[MAX_MSG_LEN+1];
                sprintf(echomsg,"%s\n",msg);
                Rio_writen(connfd,echomsg,strlen(echomsg));
 8049838:	8d 85 e3 fa ff ff    	lea    -0x51d(%ebp),%eax
 804983e:	89 04 24             	mov    %eax,(%esp)
 8049841:	e8 0a fa ff ff       	call   8049250 <strlen@plt>
 8049846:	8d 95 e3 fa ff ff    	lea    -0x51d(%ebp),%edx
 804984c:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049850:	89 1c 24             	mov    %ebx,(%esp)
 8049853:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049857:	e8 34 11 00 00       	call   804a990 <Rio_writen>
 804985c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void echo_client(pool* p){
    int i,connfd,n;
    rio_t rio;
    char buf[MAX_LINE_LEN];
    dump_pool(p);
    for(i = 0; (i <= p->maxindex)&&(p->nready>0); i++){
 8049860:	83 c7 01             	add    $0x1,%edi
 8049863:	39 be 88 01 00 00    	cmp    %edi,0x188(%esi)
 8049869:	0f 8c f9 00 00 00    	jl     8049968 <echo_client+0x1c8>
 804986f:	8b 86 84 01 00 00    	mov    0x184(%esi),%eax
 8049875:	81 85 c4 da ff ff 0c 	addl   $0x200c,-0x253c(%ebp)
 804987c:	20 00 00 
 804987f:	85 c0                	test   %eax,%eax
 8049881:	0f 8e e1 00 00 00    	jle    8049968 <echo_client+0x1c8>
        connfd = p->clientfd[i];
        rio = p->client_read_buf[i];
 8049887:	8b 85 c4 da ff ff    	mov    -0x253c(%ebp),%eax
 804988d:	8d 95 d4 da ff ff    	lea    -0x252c(%ebp),%edx
    int i,connfd,n;
    rio_t rio;
    char buf[MAX_LINE_LEN];
    dump_pool(p);
    for(i = 0; (i <= p->maxindex)&&(p->nready>0); i++){
        connfd = p->clientfd[i];
 8049893:	8b 9c be 8c 01 00 00 	mov    0x18c(%esi,%edi,4),%ebx
        rio = p->client_read_buf[i];
 804989a:	89 14 24             	mov    %edx,(%esp)
 804989d:	c7 44 24 08 0c 20 00 	movl   $0x200c,0x8(%esp)
 80498a4:	00 
 80498a5:	05 8c 11 00 00       	add    $0x118c,%eax
 80498aa:	89 44 24 04          	mov    %eax,0x4(%esp)
 80498ae:	e8 2d f7 ff ff       	call   8048fe0 <memcpy@plt>
        if(FD_ISSET(connfd, &p->ready_set)&&(connfd > 0)){
 80498b3:	89 1c 24             	mov    %ebx,(%esp)
 80498b6:	e8 15 f8 ff ff       	call   80490d0 <__fdelt_chk@plt>
 80498bb:	89 da                	mov    %ebx,%edx
 80498bd:	c1 fa 1f             	sar    $0x1f,%edx
 80498c0:	c1 ea 1b             	shr    $0x1b,%edx
 80498c3:	8d 0c 13             	lea    (%ebx,%edx,1),%ecx
 80498c6:	83 e1 1f             	and    $0x1f,%ecx
 80498c9:	29 d1                	sub    %edx,%ecx
 80498cb:	8b 84 86 04 01 00 00 	mov    0x104(%esi,%eax,4),%eax
 80498d2:	0f a3 c8             	bt     %ecx,%eax
 80498d5:	73 89                	jae    8049860 <echo_client+0xc0>
 80498d7:	85 db                	test   %ebx,%ebx
 80498d9:	7e 85                	jle    8049860 <echo_client+0xc0>

            if((n = Rio_readlineb(&rio,buf,MAX_LINE_LEN))!=0){
 80498db:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
 80498e1:	8d 95 d4 da ff ff    	lea    -0x252c(%ebp),%edx
 80498e7:	89 8d c0 da ff ff    	mov    %ecx,-0x2540(%ebp)
 80498ed:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
 80498f4:	00 
 80498f5:	89 44 24 04          	mov    %eax,0x4(%esp)
 80498f9:	89 14 24             	mov    %edx,(%esp)
 80498fc:	e8 0f 10 00 00       	call   804a910 <Rio_readlineb>
 8049901:	8b 8d c0 da ff ff    	mov    -0x2540(%ebp),%ecx
 8049907:	85 c0                	test   %eax,%eax
 8049909:	0f 85 e1 fe ff ff    	jne    80497f0 <echo_client+0x50>
                get_msg(buf,msg);
                char echomsg[MAX_MSG_LEN+1];
                sprintf(echomsg,"%s\n",msg);
                Rio_writen(connfd,echomsg,strlen(echomsg));
            }else{
                Close(connfd);
 804990f:	89 8d c0 da ff ff    	mov    %ecx,-0x2540(%ebp)
 8049915:	89 1c 24             	mov    %ebx,(%esp)
 8049918:	e8 03 17 00 00       	call   804b020 <Close>
                FD_CLR(connfd,&p->read_set);
 804991d:	89 1c 24             	mov    %ebx,(%esp)
 8049920:	e8 ab f7 ff ff       	call   80490d0 <__fdelt_chk@plt>
 8049925:	8b 8d c0 da ff ff    	mov    -0x2540(%ebp),%ecx
 804992b:	ba 01 00 00 00       	mov    $0x1,%edx
                p->clientfd[i]=EMPTY_FD;
 8049930:	c7 84 be 8c 01 00 00 	movl   $0xffffffff,0x18c(%esi,%edi,4)
 8049937:	ff ff ff ff 
void echo_client(pool* p){
    int i,connfd,n;
    rio_t rio;
    char buf[MAX_LINE_LEN];
    dump_pool(p);
    for(i = 0; (i <= p->maxindex)&&(p->nready>0); i++){
 804993b:	83 c7 01             	add    $0x1,%edi
                char echomsg[MAX_MSG_LEN+1];
                sprintf(echomsg,"%s\n",msg);
                Rio_writen(connfd,echomsg,strlen(echomsg));
            }else{
                Close(connfd);
                FD_CLR(connfd,&p->read_set);
 804993e:	d3 e2                	shl    %cl,%edx
 8049940:	89 d1                	mov    %edx,%ecx
 8049942:	f7 d1                	not    %ecx
 8049944:	21 4c 86 04          	and    %ecx,0x4(%esi,%eax,4)
                p->clientfd[i]=EMPTY_FD;
                //Free the memory space for the client
                Free(global_client_queue[connfd]);
 8049948:	8b 04 9d 40 23 85 08 	mov    0x8852340(,%ebx,4),%eax
 804994f:	89 04 24             	mov    %eax,(%esp)
 8049952:	e8 99 0c 00 00       	call   804a5f0 <Free>
void echo_client(pool* p){
    int i,connfd,n;
    rio_t rio;
    char buf[MAX_LINE_LEN];
    dump_pool(p);
    for(i = 0; (i <= p->maxindex)&&(p->nready>0); i++){
 8049957:	39 be 88 01 00 00    	cmp    %edi,0x188(%esi)
 804995d:	0f 8d 0c ff ff ff    	jge    804986f <echo_client+0xcf>
 8049963:	90                   	nop
 8049964:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
                //Free the memory space for the client
                Free(global_client_queue[connfd]);
            }        
        }  
    }
}
 8049968:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804996b:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 8049972:	75 0b                	jne    804997f <echo_client+0x1df>
 8049974:	81 c4 5c 25 00 00    	add    $0x255c,%esp
 804997a:	5b                   	pop    %ebx
 804997b:	5e                   	pop    %esi
 804997c:	5f                   	pop    %edi
 804997d:	5d                   	pop    %ebp
 804997e:	c3                   	ret    
 804997f:	e8 0c f7 ff ff       	call   8049090 <__stack_chk_fail@plt>
 8049984:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804998a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08049990 <init_client>:
}
/**
 * void create_client(int connfd)
 * Initialize a client and add it in the global client queue
 */
void init_client(int connfd){
 8049990:	55                   	push   %ebp
 8049991:	89 e5                	mov    %esp,%ebp
 8049993:	53                   	push   %ebx
 8049994:	83 ec 14             	sub    $0x14,%esp
 8049997:	8b 5d 08             	mov    0x8(%ebp),%ebx
    client *newclient = Malloc(sizeof(client));
 804999a:	c7 04 24 50 00 00 00 	movl   $0x50,(%esp)
 80499a1:	e8 aa 14 00 00       	call   804ae50 <Malloc>
    newclient->clientfd = connfd;
 80499a6:	89 18                	mov    %ebx,(%eax)
    newclient->nick_is_set = 0;
 80499a8:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    newclient->user_is_set = 0;
 80499af:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
    newclient->channel_id = EMPTY_FD;
 80499b6:	c7 40 44 ff ff ff ff 	movl   $0xffffffff,0x44(%eax)
    global_client_queue[connfd] = newclient;
 80499bd:	89 04 9d 40 23 85 08 	mov    %eax,0x8852340(,%ebx,4)

}
 80499c4:	83 c4 14             	add    $0x14,%esp
 80499c7:	5b                   	pop    %ebx
 80499c8:	5d                   	pop    %ebp
 80499c9:	c3                   	ret    
 80499ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

080499d0 <add_client>:
}
/**
 * void add_client(int connfd, pool* p)
 * add a client t the client pool
 */
void add_client(int connfd, pool* p){
 80499d0:	55                   	push   %ebp
 80499d1:	89 e5                	mov    %esp,%ebp
 80499d3:	57                   	push   %edi
 80499d4:	56                   	push   %esi
 80499d5:	53                   	push   %ebx
    int i;
    //the newly added client takes up a descriptor
    p->nready--;
 80499d6:	31 db                	xor    %ebx,%ebx
}
/**
 * void add_client(int connfd, pool* p)
 * add a client t the client pool
 */
void add_client(int connfd, pool* p){
 80499d8:	83 ec 1c             	sub    $0x1c,%esp
 80499db:	8b 75 0c             	mov    0xc(%ebp),%esi
 80499de:	8b 7d 08             	mov    0x8(%ebp),%edi
    int i;
    //the newly added client takes up a descriptor
    p->nready--;
 80499e1:	83 ae 84 01 00 00 01 	subl   $0x1,0x184(%esi)
 80499e8:	eb 15                	jmp    80499ff <add_client+0x2f>
 80499ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    //search the pool and find the empty position for the coming descriptor
    for(i = 0; i < FD_SETSIZE; i++){
 80499f0:	83 c3 01             	add    $0x1,%ebx
 80499f3:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
 80499f9:	0f 84 81 00 00 00    	je     8049a80 <add_client+0xb0>
       if(p->clientfd[i] == EMPTY_FD){
 80499ff:	83 bc 9e 8c 01 00 00 	cmpl   $0xffffffff,0x18c(%esi,%ebx,4)
 8049a06:	ff 
 8049a07:	75 e7                	jne    80499f0 <add_client+0x20>
            //set the added descriptor to the read set of the pool
            FD_SET(connfd,&p->read_set);
 8049a09:	89 3c 24             	mov    %edi,(%esp)
 8049a0c:	e8 bf f6 ff ff       	call   80490d0 <__fdelt_chk@plt>
 8049a11:	89 fa                	mov    %edi,%edx
 8049a13:	c1 fa 1f             	sar    $0x1f,%edx
 8049a16:	c1 ea 1b             	shr    $0x1b,%edx
 8049a19:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
 8049a1c:	83 e1 1f             	and    $0x1f,%ecx
 8049a1f:	29 d1                	sub    %edx,%ecx
 8049a21:	ba 01 00 00 00       	mov    $0x1,%edx
 8049a26:	d3 e2                	shl    %cl,%edx
 8049a28:	09 54 86 04          	or     %edx,0x4(%esi,%eax,4)
            //add the client descriptor to the empty room in the client list of the pool
            p->clientfd[i] = connfd;
            Rio_readinitb(&p->client_read_buf[i], connfd);
 8049a2c:	69 c3 0c 20 00 00    	imul   $0x200c,%ebx,%eax
    for(i = 0; i < FD_SETSIZE; i++){
       if(p->clientfd[i] == EMPTY_FD){
            //set the added descriptor to the read set of the pool
            FD_SET(connfd,&p->read_set);
            //add the client descriptor to the empty room in the client list of the pool
            p->clientfd[i] = connfd;
 8049a32:	89 bc 9e 8c 01 00 00 	mov    %edi,0x18c(%esi,%ebx,4)
            Rio_readinitb(&p->client_read_buf[i], connfd);
 8049a39:	89 7c 24 04          	mov    %edi,0x4(%esp)
 8049a3d:	8d 84 06 8c 11 00 00 	lea    0x118c(%esi,%eax,1),%eax
 8049a44:	89 04 24             	mov    %eax,(%esp)
 8049a47:	e8 e4 08 00 00       	call   804a330 <Rio_readinitb>
            if(p->maxindex < i){
 8049a4c:	39 9e 88 01 00 00    	cmp    %ebx,0x188(%esi)
 8049a52:	7d 06                	jge    8049a5a <add_client+0x8a>
                p->maxindex = i;
 8049a54:	89 9e 88 01 00 00    	mov    %ebx,0x188(%esi)
            }
            if(p->maxfd < connfd){
 8049a5a:	3b 3e                	cmp    (%esi),%edi
 8049a5c:	7f 1a                	jg     8049a78 <add_client+0xa8>
            }
            break;
       } 
    
    }
    if(i == FD_SETSIZE){
 8049a5e:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
 8049a64:	74 1a                	je     8049a80 <add_client+0xb0>
        unix_error("Clients full.");
        return;
    }
   //create a real client in the global client queue 
    init_client(connfd);
 8049a66:	89 7d 08             	mov    %edi,0x8(%ebp)
    
}
 8049a69:	83 c4 1c             	add    $0x1c,%esp
 8049a6c:	5b                   	pop    %ebx
 8049a6d:	5e                   	pop    %esi
 8049a6e:	5f                   	pop    %edi
 8049a6f:	5d                   	pop    %ebp
    if(i == FD_SETSIZE){
        unix_error("Clients full.");
        return;
    }
   //create a real client in the global client queue 
    init_client(connfd);
 8049a70:	e9 1b ff ff ff       	jmp    8049990 <init_client>
 8049a75:	8d 76 00             	lea    0x0(%esi),%esi
            Rio_readinitb(&p->client_read_buf[i], connfd);
            if(p->maxindex < i){
                p->maxindex = i;
            }
            if(p->maxfd < connfd){
                p->maxfd = connfd;
 8049a78:	89 3e                	mov    %edi,(%esi)
 8049a7a:	eb e2                	jmp    8049a5e <add_client+0x8e>
 8049a7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
            break;
       } 
    
    }
    if(i == FD_SETSIZE){
        unix_error("Clients full.");
 8049a80:	c7 45 08 c0 b7 04 08 	movl   $0x804b7c0,0x8(%ebp)
        return;
    }
   //create a real client in the global client queue 
    init_client(connfd);
    
}
 8049a87:	83 c4 1c             	add    $0x1c,%esp
 8049a8a:	5b                   	pop    %ebx
 8049a8b:	5e                   	pop    %esi
 8049a8c:	5f                   	pop    %edi
 8049a8d:	5d                   	pop    %ebp
            break;
       } 
    
    }
    if(i == FD_SETSIZE){
        unix_error("Clients full.");
 8049a8e:	e9 2d 0e 00 00       	jmp    804a8c0 <unix_error>
 8049a93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049a99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049aa0 <init_node>:
 *
 * Takes care of initializing a node for an IRC server
 * from the given command line arguments
 */
void init_node( int argc, char *argv[] )
{
 8049aa0:	55                   	push   %ebp
 8049aa1:	89 e5                	mov    %esp,%ebp
 8049aa3:	53                   	push   %ebx
 8049aa4:	83 ec 14             	sub    $0x14,%esp
 8049aa7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int i;

    if( argc < 3 )
 8049aaa:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
 8049aae:	0f 8e 7e 00 00 00    	jle    8049b32 <init_node+0x92>
  return (int) strtol (__nptr, (char **) NULL, 10);
}
__extern_inline long int
__NTH (atol (__const char *__nptr))
{
  return strtol (__nptr, (char **) NULL, 10);
 8049ab4:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 8049abb:	00 
 8049abc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049ac3:	00 
 8049ac4:	8b 43 04             	mov    0x4(%ebx),%eax
 8049ac7:	89 04 24             	mov    %eax,(%esp)
 8049aca:	e8 61 f9 ff ff       	call   8049430 <strtol@plt>
        printf( "%s <nodeID> <config file>\n", argv[0] );
        exit( 0 );
    }

    /* Parse nodeID */
    curr_nodeID = atol( argv[1] );
 8049acf:	a3 30 23 85 08       	mov    %eax,0x8852330

    /* Store  */
    rt_parse_config_file(argv[0], &curr_node_config_file, argv[2] );
 8049ad4:	8b 43 08             	mov    0x8(%ebx),%eax
 8049ad7:	c7 44 24 04 40 33 85 	movl   $0x8853340,0x4(%esp)
 8049ade:	08 
 8049adf:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049ae3:	8b 03                	mov    (%ebx),%eax
 8049ae5:	89 04 24             	mov    %eax,(%esp)
 8049ae8:	e8 d3 01 00 00       	call   8049cc0 <rt_parse_config_file>

    /* Get config file for this node */
    for( i = 0; i < curr_node_config_file.size; ++i )
 8049aed:	8b 0d 40 33 85 08    	mov    0x8853340,%ecx
 8049af3:	85 c9                	test   %ecx,%ecx
 8049af5:	7e 2b                	jle    8049b22 <init_node+0x82>
 8049af7:	8b 1d 30 23 85 08    	mov    0x8852330,%ebx
 8049afd:	b8 44 33 85 08       	mov    $0x8853344,%eax
 8049b02:	8b 15 2c 23 85 08    	mov    0x885232c,%edx
 * void init_node( int argc, char *argv[] )
 *
 * Takes care of initializing a node for an IRC server
 * from the given command line arguments
 */
void init_node( int argc, char *argv[] )
 8049b08:	c1 e1 04             	shl    $0x4,%ecx
 8049b0b:	01 c1                	add    %eax,%ecx
 8049b0d:	8d 76 00             	lea    0x0(%esi),%esi
    /* Store  */
    rt_parse_config_file(argv[0], &curr_node_config_file, argv[2] );

    /* Get config file for this node */
    for( i = 0; i < curr_node_config_file.size; ++i )
        if( curr_node_config_file.entries[i].nodeID == curr_nodeID )
 8049b10:	3b 18                	cmp    (%eax),%ebx
 8049b12:	0f 44 d0             	cmove  %eax,%edx
 8049b15:	83 c0 10             	add    $0x10,%eax

    /* Store  */
    rt_parse_config_file(argv[0], &curr_node_config_file, argv[2] );

    /* Get config file for this node */
    for( i = 0; i < curr_node_config_file.size; ++i )
 8049b18:	39 c8                	cmp    %ecx,%eax
 8049b1a:	75 f4                	jne    8049b10 <init_node+0x70>
 8049b1c:	89 15 2c 23 85 08    	mov    %edx,0x885232c
        if( curr_node_config_file.entries[i].nodeID == curr_nodeID )
             curr_node_config_entry = &curr_node_config_file.entries[i];

    /* Check to see if nodeID is valid */
    if( !curr_node_config_entry )
 8049b22:	8b 1d 2c 23 85 08    	mov    0x885232c,%ebx
 8049b28:	85 db                	test   %ebx,%ebx
 8049b2a:	74 2c                	je     8049b58 <init_node+0xb8>
    {
        printf( "Invalid NodeID\n" );
        exit(1);
    }
}
 8049b2c:	83 c4 14             	add    $0x14,%esp
 8049b2f:	5b                   	pop    %ebx
 8049b30:	5d                   	pop    %ebp
 8049b31:	c3                   	ret    
}

__extern_always_inline int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
 8049b32:	8b 03                	mov    (%ebx),%eax
 8049b34:	c7 44 24 04 ce b7 04 	movl   $0x804b7ce,0x4(%esp)
 8049b3b:	08 
 8049b3c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049b43:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b47:	e8 04 f8 ff ff       	call   8049350 <__printf_chk@plt>
    int i;

    if( argc < 3 )
    {
        printf( "%s <nodeID> <config file>\n", argv[0] );
        exit( 0 );
 8049b4c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049b53:	e8 78 f6 ff ff       	call   80491d0 <exit@plt>
 8049b58:	c7 44 24 04 e9 b7 04 	movl   $0x804b7e9,0x4(%esp)
 8049b5f:	08 
 8049b60:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049b67:	e8 e4 f7 ff ff       	call   8049350 <__printf_chk@plt>

    /* Check to see if nodeID is valid */
    if( !curr_node_config_entry )
    {
        printf( "Invalid NodeID\n" );
        exit(1);
 8049b6c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049b73:	e8 58 f6 ff ff       	call   80491d0 <exit@plt>
 8049b78:	90                   	nop
 8049b79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049b80 <main>:
void init_client(int connfd);
void echo_client(pool* p);

/* Main */
int main( int argc, char *argv[] )
{
 8049b80:	55                   	push   %ebp
 8049b81:	89 e5                	mov    %esp,%ebp
 8049b83:	83 e4 f0             	and    $0xfffffff0,%esp
 8049b86:	57                   	push   %edi
 8049b87:	56                   	push   %esi
 8049b88:	53                   	push   %ebx
 8049b89:	83 ec 54             	sub    $0x54,%esp
 8049b8c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049b92:	89 44 24 4c          	mov    %eax,0x4c(%esp)
 8049b96:	31 c0                	xor    %eax,%eax
    int listenfd, connfd;
    struct sockaddr_in cliaddr;
    socklen_t addrlen = sizeof(struct sockaddr_in);
   // pool *pool = Malloc(sizeof(pool));
    init_node( argc, argv );
 8049b98:	8b 45 0c             	mov    0xc(%ebp),%eax
/* Main */
int main( int argc, char *argv[] )
{
    int listenfd, connfd;
    struct sockaddr_in cliaddr;
    socklen_t addrlen = sizeof(struct sockaddr_in);
 8049b9b:	c7 44 24 38 10 00 00 	movl   $0x10,0x38(%esp)
 8049ba2:	00 
   // pool *pool = Malloc(sizeof(pool));
    init_node( argc, argv );
 8049ba3:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049ba7:	8b 45 08             	mov    0x8(%ebp),%eax
 8049baa:	89 04 24             	mov    %eax,(%esp)
 8049bad:	e8 ee fe ff ff       	call   8049aa0 <init_node>
 8049bb2:	a1 2c 23 85 08       	mov    0x885232c,%eax
 8049bb7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8049bbb:	c7 44 24 04 54 b8 04 	movl   $0x804b854,0x4(%esp)
 8049bc2:	08 
 8049bc3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049bca:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049bce:	a1 30 23 85 08       	mov    0x8852330,%eax
 8049bd3:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049bd7:	e8 74 f7 ff ff       	call   8049350 <__printf_chk@plt>
 *open_listenfd - open and return a listening socket on port, it is a combination of the following steps:
 * 1.create a socket descriptor
 * 2.bind the socket descriptor with a local protocol
 * 3.Make it a listening socket ready to accept connection requests 
 */
    listenfd=Open_listenfd((int)curr_node_config_entry->irc_port);
 8049bdc:	a1 2c 23 85 08       	mov    0x885232c,%eax
 8049be1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8049be5:	89 04 24             	mov    %eax,(%esp)
 8049be8:	e8 53 19 00 00       	call   804b540 <Open_listenfd>
    init_pool(listenfd,&client_pool);
 8049bed:	c7 44 24 04 a0 e1 04 	movl   $0x804e1a0,0x4(%esp)
 8049bf4:	08 
 *open_listenfd - open and return a listening socket on port, it is a combination of the following steps:
 * 1.create a socket descriptor
 * 2.bind the socket descriptor with a local protocol
 * 3.Make it a listening socket ready to accept connection requests 
 */
    listenfd=Open_listenfd((int)curr_node_config_entry->irc_port);
 8049bf5:	89 c3                	mov    %eax,%ebx
    init_pool(listenfd,&client_pool);
 8049bf7:	89 04 24             	mov    %eax,(%esp)
 8049bfa:	e8 91 fa ff ff       	call   8049690 <init_pool>
 8049bff:	89 da                	mov    %ebx,%edx
 8049c01:	b9 20 00 00 00       	mov    $0x20,%ecx
 8049c06:	89 d8                	mov    %ebx,%eax
 8049c08:	c1 fa 1f             	sar    $0x1f,%edx
 8049c0b:	f7 f9                	idiv   %ecx
 8049c0d:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
 8049c14:	00 
 8049c15:	89 d1                	mov    %edx,%ecx
 8049c17:	d3 64 24 2c          	shll   %cl,0x2c(%esp)
 8049c1b:	eb 0f                	jmp    8049c2c <main+0xac>
 8049c1d:	8d 76 00             	lea    0x0(%esi),%esi
            connfd = Accept(listenfd, (SA*)&cliaddr,&addrlen);
            //add a client in the global client queue
            add_client(connfd, &client_pool);
        }
        //echo the command from the clients
        echo_client(&client_pool);
 8049c20:	c7 04 24 a0 e1 04 08 	movl   $0x804e1a0,(%esp)
 8049c27:	e8 74 fb ff ff       	call   80497a0 <echo_client>
    listenfd=Open_listenfd((int)curr_node_config_entry->irc_port);
    init_pool(listenfd,&client_pool);
    while(1){
        //all descriptors in the read set was ready for read
        client_pool.ready_set = client_pool.read_set; 
        client_pool.nready = Select(client_pool.maxfd+1,&(client_pool.ready_set),NULL,NULL,NULL);
 8049c2c:	a1 a0 e1 04 08       	mov    0x804e1a0,%eax
 */
    listenfd=Open_listenfd((int)curr_node_config_entry->irc_port);
    init_pool(listenfd,&client_pool);
    while(1){
        //all descriptors in the read set was ready for read
        client_pool.ready_set = client_pool.read_set; 
 8049c31:	bf a4 e2 04 08       	mov    $0x804e2a4,%edi
 8049c36:	be a4 e1 04 08       	mov    $0x804e1a4,%esi
 8049c3b:	b9 20 00 00 00       	mov    $0x20,%ecx
        client_pool.nready = Select(client_pool.maxfd+1,&(client_pool.ready_set),NULL,NULL,NULL);
 8049c40:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049c47:	00 
 */
    listenfd=Open_listenfd((int)curr_node_config_entry->irc_port);
    init_pool(listenfd,&client_pool);
    while(1){
        //all descriptors in the read set was ready for read
        client_pool.ready_set = client_pool.read_set; 
 8049c48:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        client_pool.nready = Select(client_pool.maxfd+1,&(client_pool.ready_set),NULL,NULL,NULL);
 8049c4a:	83 c0 01             	add    $0x1,%eax
 8049c4d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 8049c54:	00 
 8049c55:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049c5c:	00 
 8049c5d:	c7 44 24 04 a4 e2 04 	movl   $0x804e2a4,0x4(%esp)
 8049c64:	08 
 8049c65:	89 04 24             	mov    %eax,(%esp)
 8049c68:	e8 63 13 00 00       	call   804afd0 <Select>

        if(FD_ISSET(listenfd,&(client_pool.ready_set))){
 8049c6d:	89 1c 24             	mov    %ebx,(%esp)
    listenfd=Open_listenfd((int)curr_node_config_entry->irc_port);
    init_pool(listenfd,&client_pool);
    while(1){
        //all descriptors in the read set was ready for read
        client_pool.ready_set = client_pool.read_set; 
        client_pool.nready = Select(client_pool.maxfd+1,&(client_pool.ready_set),NULL,NULL,NULL);
 8049c70:	89 07                	mov    %eax,(%edi)

        if(FD_ISSET(listenfd,&(client_pool.ready_set))){
 8049c72:	e8 59 f4 ff ff       	call   80490d0 <__fdelt_chk@plt>
 8049c77:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 8049c7b:	85 14 85 a4 e2 04 08 	test   %edx,0x804e2a4(,%eax,4)
 8049c82:	74 9c                	je     8049c20 <main+0xa0>
            //return the next ready completed connection from the front of the completed connection queue
            connfd = Accept(listenfd, (SA*)&cliaddr,&addrlen);
 8049c84:	8d 4c 24 38          	lea    0x38(%esp),%ecx
 8049c88:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 8049c8c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049c90:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049c94:	89 1c 24             	mov    %ebx,(%esp)
 8049c97:	e8 54 0e 00 00       	call   804aaf0 <Accept>
            //add a client in the global client queue
            add_client(connfd, &client_pool);
 8049c9c:	c7 44 24 04 a0 e1 04 	movl   $0x804e1a0,0x4(%esp)
 8049ca3:	08 
 8049ca4:	89 04 24             	mov    %eax,(%esp)
 8049ca7:	e8 24 fd ff ff       	call   80499d0 <add_client>
 8049cac:	e9 6f ff ff ff       	jmp    8049c20 <main+0xa0>
 8049cb1:	66 90                	xchg   %ax,%ax
 8049cb3:	66 90                	xchg   %ax,%ax
 8049cb5:	66 90                	xchg   %ax,%ax
 8049cb7:	66 90                	xchg   %ax,%ax
 8049cb9:	66 90                	xchg   %ax,%ax
 8049cbb:	66 90                	xchg   %ax,%ax
 8049cbd:	66 90                	xchg   %ax,%ax
 8049cbf:	90                   	nop

08049cc0 <rt_parse_config_file>:
}


void rt_parse_config_file(const char *cmd, rt_config_file_t *config, 
			  const char *filename)
{
 8049cc0:	55                   	push   %ebp
 8049cc1:	89 e5                	mov    %esp,%ebp
 8049cc3:	57                   	push   %edi
 8049cc4:	56                   	push   %esi
 8049cc5:	53                   	push   %ebx
 8049cc6:	81 ec 4c 02 00 00    	sub    $0x24c,%esp
 8049ccc:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ccf:	8b 5d 10             	mov    0x10(%ebp),%ebx
 8049cd2:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 8049cd9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8049cdc:	31 d2                	xor    %edx,%edx
 8049cde:	8b 75 0c             	mov    0xc(%ebp),%esi
    char line[MAX_CONFIG_FILE_LINE_LEN];
    char hostname[MAX_CONFIG_FILE_LINE_LEN];
    struct hostent *host;
    int i, ret;

    file = fopen(filename, "r");
 8049ce1:	c7 44 24 04 0d be 04 	movl   $0x804be0d,0x4(%esp)
 8049ce8:	08 
}


void rt_parse_config_file(const char *cmd, rt_config_file_t *config, 
			  const char *filename)
{
 8049ce9:	89 85 cc fd ff ff    	mov    %eax,-0x234(%ebp)
    char line[MAX_CONFIG_FILE_LINE_LEN];
    char hostname[MAX_CONFIG_FILE_LINE_LEN];
    struct hostent *host;
    int i, ret;

    file = fopen(filename, "r");
 8049cef:	89 1c 24             	mov    %ebx,(%esp)
 8049cf2:	e8 19 f6 ff ff       	call   8049310 <fopen@plt>
    if (! file) {
 8049cf7:	85 c0                	test   %eax,%eax
    char line[MAX_CONFIG_FILE_LINE_LEN];
    char hostname[MAX_CONFIG_FILE_LINE_LEN];
    struct hostent *host;
    int i, ret;

    file = fopen(filename, "r");
 8049cf9:	89 85 d0 fd ff ff    	mov    %eax,-0x230(%ebp)
    if (! file) {
 8049cff:	0f 84 6c 01 00 00    	je     8049e71 <rt_parse_config_file+0x1b1>
	fprintf(stderr, "%s: can't open config_file = %s: ", cmd, filename);
	perror(NULL);
	exit(255);
    }

    config->size = 0;
 8049d05:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 8049d0b:	8d bd e5 fe ff ff    	lea    -0x11b(%ebp),%edi
 8049d11:	31 db                	xor    %ebx,%ebx
 8049d13:	90                   	nop
 8049d14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
 8049d18:	8b 95 d0 fd ff ff    	mov    -0x230(%ebp),%edx
 8049d1e:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
 8049d25:	00 
 8049d26:	89 3c 24             	mov    %edi,(%esp)
 8049d29:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049d2d:	e8 de f2 ff ff       	call   8049010 <fgets@plt>
    
    for (i=0; i<MAX_CONFIG_FILE_LINES; i++) {
	if (! fgets(line, MAX_CONFIG_FILE_LINE_LEN, file) ) {
 8049d32:	85 c0                	test   %eax,%eax
 8049d34:	0f 84 8a 00 00 00    	je     8049dc4 <rt_parse_config_file+0x104>
	    break;
	}
	/* skip blank lines */
	if (line[0] == '\n') {
 8049d3a:	80 bd e5 fe ff ff 0a 	cmpb   $0xa,-0x11b(%ebp)
 8049d41:	74 75                	je     8049db8 <rt_parse_config_file+0xf8>
	    continue;
	}

	ret = sscanf(line, "%lu %s %hu %hu %hu", 
 8049d43:	89 d8                	mov    %ebx,%eax
 8049d45:	c1 e0 04             	shl    $0x4,%eax
 8049d48:	89 85 d4 fd ff ff    	mov    %eax,-0x22c(%ebp)
 8049d4e:	8d 04 06             	lea    (%esi,%eax,1),%eax
 8049d51:	8d 50 10             	lea    0x10(%eax),%edx
 8049d54:	89 54 24 18          	mov    %edx,0x18(%esp)
 8049d58:	8d 50 0e             	lea    0xe(%eax),%edx
 8049d5b:	89 54 24 14          	mov    %edx,0x14(%esp)
 8049d5f:	8d 50 0c             	lea    0xc(%eax),%edx
 8049d62:	83 c0 04             	add    $0x4,%eax
 8049d65:	89 54 24 10          	mov    %edx,0x10(%esp)
 8049d69:	8d 95 e6 fd ff ff    	lea    -0x21a(%ebp),%edx
 8049d6f:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049d73:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049d77:	c7 44 24 04 89 b8 04 	movl   $0x804b889,0x4(%esp)
 8049d7e:	08 
 8049d7f:	89 3c 24             	mov    %edi,(%esp)
 8049d82:	e8 79 f5 ff ff       	call   8049300 <__isoc99_sscanf@plt>
		     &config->entries[i].nodeID,
		     hostname,
		     &config->entries[i].routing_port,
		     &config->entries[i].local_port,
		     &config->entries[i].irc_port);
	if (ret != 5) {
 8049d87:	83 f8 05             	cmp    $0x5,%eax
 8049d8a:	75 74                	jne    8049e00 <rt_parse_config_file+0x140>
	    fprintf(stderr, "%s: bad line in config_file: %s", cmd, line);
	    exit(255);
	}

	host = gethostbyname(hostname);
 8049d8c:	8d 95 e6 fd ff ff    	lea    -0x21a(%ebp),%edx
 8049d92:	89 14 24             	mov    %edx,(%esp)
 8049d95:	e8 86 f6 ff ff       	call   8049420 <gethostbyname@plt>
	if (host == NULL) {
 8049d9a:	85 c0                	test   %eax,%eax
 8049d9c:	0f 84 95 00 00 00    	je     8049e37 <rt_parse_config_file+0x177>
	    fprintf(stderr, "%s: invalid hostname in config file = %s\n",
		    cmd, hostname);
	    exit(255);
	}
	/* assume that we want to use the first IP address if multiple */
	config->entries[i].ipaddr = ntohl( *(in_addr_t *)host->h_addr );
 8049da2:	8b 40 10             	mov    0x10(%eax),%eax
 8049da5:	8b 95 d4 fd ff ff    	mov    -0x22c(%ebp),%edx
 8049dab:	8b 00                	mov    (%eax),%eax
 8049dad:	8b 00                	mov    (%eax),%eax

	++config->size;
 8049daf:	83 06 01             	addl   $0x1,(%esi)
	    fprintf(stderr, "%s: invalid hostname in config file = %s\n",
		    cmd, hostname);
	    exit(255);
	}
	/* assume that we want to use the first IP address if multiple */
	config->entries[i].ipaddr = ntohl( *(in_addr_t *)host->h_addr );
 8049db2:	0f c8                	bswap  %eax
 8049db4:	89 44 16 08          	mov    %eax,0x8(%esi,%edx,1)
	exit(255);
    }

    config->size = 0;
    
    for (i=0; i<MAX_CONFIG_FILE_LINES; i++) {
 8049db8:	83 c3 01             	add    $0x1,%ebx
 8049dbb:	83 fb 20             	cmp    $0x20,%ebx
 8049dbe:	0f 85 54 ff ff ff    	jne    8049d18 <rt_parse_config_file+0x58>
	/* assume that we want to use the first IP address if multiple */
	config->entries[i].ipaddr = ntohl( *(in_addr_t *)host->h_addr );

	++config->size;
    }
    if (getc(file) != EOF) {
 8049dc4:	8b 85 d0 fd ff ff    	mov    -0x230(%ebp),%eax
 8049dca:	89 04 24             	mov    %eax,(%esp)
 8049dcd:	e8 ce f2 ff ff       	call   80490a0 <_IO_getc@plt>
 8049dd2:	83 f8 ff             	cmp    $0xffffffff,%eax
 8049dd5:	75 7e                	jne    8049e55 <rt_parse_config_file+0x195>
	fprintf(stderr, "%s: too many lines in config_file (max = %d)\n",
		cmd, MAX_CONFIG_FILE_LINES);
	exit(255);
    }

    fclose(file);
 8049dd7:	8b 85 d0 fd ff ff    	mov    -0x230(%ebp),%eax
 8049ddd:	89 04 24             	mov    %eax,(%esp)
 8049de0:	e8 3b f2 ff ff       	call   8049020 <fclose@plt>
}
 8049de5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8049de8:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
 8049def:	0f 85 bf 00 00 00    	jne    8049eb4 <rt_parse_config_file+0x1f4>
 8049df5:	81 c4 4c 02 00 00    	add    $0x24c,%esp
 8049dfb:	5b                   	pop    %ebx
 8049dfc:	5e                   	pop    %esi
 8049dfd:	5f                   	pop    %edi
 8049dfe:	5d                   	pop    %ebp
 8049dff:	c3                   	ret    

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 8049e00:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
 8049e06:	89 7c 24 10          	mov    %edi,0x10(%esp)
 8049e0a:	c7 44 24 08 7c b9 04 	movl   $0x804b97c,0x8(%esp)
 8049e11:	08 
 8049e12:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049e16:	a1 80 e1 04 08       	mov    0x804e180,%eax
 8049e1b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8049e22:	00 
 8049e23:	89 04 24             	mov    %eax,(%esp)
 8049e26:	e8 b5 f5 ff ff       	call   80493e0 <__fprintf_chk@plt>

	host = gethostbyname(hostname);
	if (host == NULL) {
	    fprintf(stderr, "%s: invalid hostname in config file = %s\n",
		    cmd, hostname);
	    exit(255);
 8049e2b:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 8049e32:	e8 99 f3 ff ff       	call   80491d0 <exit@plt>
 8049e37:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
 8049e3d:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
 8049e43:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049e47:	c7 44 24 08 9c b9 04 	movl   $0x804b99c,0x8(%esp)
 8049e4e:	08 
 8049e4f:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049e53:	eb c1                	jmp    8049e16 <rt_parse_config_file+0x156>
 8049e55:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
 8049e5b:	c7 44 24 10 20 00 00 	movl   $0x20,0x10(%esp)
 8049e62:	00 
 8049e63:	c7 44 24 08 c8 b9 04 	movl   $0x804b9c8,0x8(%esp)
 8049e6a:	08 
 8049e6b:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049e6f:	eb a5                	jmp    8049e16 <rt_parse_config_file+0x156>
 8049e71:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
 8049e77:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 8049e7b:	c7 44 24 08 58 b9 04 	movl   $0x804b958,0x8(%esp)
 8049e82:	08 
 8049e83:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8049e8a:	00 
 8049e8b:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049e8f:	a1 80 e1 04 08       	mov    0x804e180,%eax
 8049e94:	89 04 24             	mov    %eax,(%esp)
 8049e97:	e8 44 f5 ff ff       	call   80493e0 <__fprintf_chk@plt>
    int i, ret;

    file = fopen(filename, "r");
    if (! file) {
	fprintf(stderr, "%s: can't open config_file = %s: ", cmd, filename);
	perror(NULL);
 8049e9c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049ea3:	e8 58 f2 ff ff       	call   8049100 <perror@plt>
	exit(255);
 8049ea8:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 8049eaf:	e8 1c f3 ff ff       	call   80491d0 <exit@plt>
		cmd, MAX_CONFIG_FILE_LINES);
	exit(255);
    }

    fclose(file);
}
 8049eb4:	e8 d7 f1 ff ff       	call   8049090 <__stack_chk_fail@plt>
 8049eb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049ec0 <parse_long>:

void parse_long(const char* arg, 
		unsigned long* value, 
		const char* prefix,
		const char* varname)
{
 8049ec0:	55                   	push   %ebp
 8049ec1:	89 e5                	mov    %esp,%ebp
 8049ec3:	83 ec 58             	sub    $0x58,%esp
 8049ec6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
 8049ec9:	89 c3                	mov    %eax,%ebx
  char* endptr;

  *value = strtoul(arg, &endptr, 0);
 8049ecb:	8d 45 e4             	lea    -0x1c(%ebp),%eax

void parse_long(const char* arg, 
		unsigned long* value, 
		const char* prefix,
		const char* varname)
{
 8049ece:	89 75 f8             	mov    %esi,-0x8(%ebp)
 8049ed1:	89 d6                	mov    %edx,%esi
 8049ed3:	89 7d fc             	mov    %edi,-0x4(%ebp)
 8049ed6:	8b 7d 08             	mov    0x8(%ebp),%edi
 8049ed9:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  char* endptr;

  *value = strtoul(arg, &endptr, 0);
 8049edc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049ee3:	00 
 8049ee4:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049ee8:	89 1c 24             	mov    %ebx,(%esp)
 8049eeb:	e8 30 f3 ff ff       	call   8049220 <strtoul@plt>
 8049ef0:	89 06                	mov    %eax,(%esi)

  if (*endptr != '\0' && !isspace(*endptr)) {
 8049ef2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8049ef5:	0f b6 10             	movzbl (%eax),%edx
 8049ef8:	84 d2                	test   %dl,%dl
 8049efa:	74 5c                	je     8049f58 <parse_long+0x98>
 8049efc:	88 55 d0             	mov    %dl,-0x30(%ebp)
 8049eff:	e8 6c f5 ff ff       	call   8049470 <__ctype_b_loc@plt>
 8049f04:	0f b6 55 d0          	movzbl -0x30(%ebp),%edx
 8049f08:	0f be d2             	movsbl %dl,%edx
 8049f0b:	8b 00                	mov    (%eax),%eax
 8049f0d:	f6 44 50 01 20       	testb  $0x20,0x1(%eax,%edx,2)
 8049f12:	75 44                	jne    8049f58 <parse_long+0x98>

    /* print an error message */
    if (prefix != NULL && varname != NULL) {
 8049f14:	85 ff                	test   %edi,%edi
 8049f16:	74 50                	je     8049f68 <parse_long+0xa8>
 8049f18:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049f1b:	85 c0                	test   %eax,%eax
 8049f1d:	74 49                	je     8049f68 <parse_long+0xa8>
 8049f1f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8049f22:	89 5c 24 14          	mov    %ebx,0x14(%esp)
 8049f26:	89 7c 24 10          	mov    %edi,0x10(%esp)
 8049f2a:	c7 44 24 08 9c b8 04 	movl   $0x804b89c,0x8(%esp)
 8049f31:	08 
 8049f32:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049f36:	a1 80 e1 04 08       	mov    0x804e180,%eax
 8049f3b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8049f42:	00 
 8049f43:	89 04 24             	mov    %eax,(%esp)
 8049f46:	e8 95 f4 ff ff       	call   80493e0 <__fprintf_chk@plt>
	fprintf(stderr, "%s: invalid %s = %s\n", prefix, varname, arg);
	exit(255);
 8049f4b:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 8049f52:	e8 79 f2 ff ff       	call   80491d0 <exit@plt>
 8049f57:	90                   	nop
    }
    exit(255);
  }
}
 8049f58:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 8049f5b:	8b 75 f8             	mov    -0x8(%ebp),%esi
 8049f5e:	8b 7d fc             	mov    -0x4(%ebp),%edi
 8049f61:	89 ec                	mov    %ebp,%esp
 8049f63:	5d                   	pop    %ebp
 8049f64:	c3                   	ret    
 8049f65:	8d 76 00             	lea    0x0(%esi),%esi
    /* print an error message */
    if (prefix != NULL && varname != NULL) {
	fprintf(stderr, "%s: invalid %s = %s\n", prefix, varname, arg);
	exit(255);
    }
    exit(255);
 8049f68:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 8049f6f:	e8 5c f2 ff ff       	call   80491d0 <exit@plt>
 8049f74:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049f7a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08049f80 <rt_parse_command_line>:
		       unsigned long* value, 
		       const char* prefix,
		       const char* varname);

void rt_parse_command_line(rt_args_t *args, int argc, char *const *argv)
{
 8049f80:	55                   	push   %ebp
}

__extern_always_inline void
__NTH (bzero (void *__dest, size_t __len))
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __bos0 (__dest));
 8049f81:	31 c0                	xor    %eax,%eax
 8049f83:	89 e5                	mov    %esp,%ebp
 8049f85:	b9 86 00 00 00       	mov    $0x86,%ecx
 8049f8a:	57                   	push   %edi
 8049f8b:	56                   	push   %esi
 8049f8c:	53                   	push   %ebx
 8049f8d:	83 ec 4c             	sub    $0x4c,%esp
 8049f90:	8b 5d 08             	mov    0x8(%ebp),%ebx
 8049f93:	8b 75 10             	mov    0x10(%ebp),%esi
 8049f96:	89 df                	mov    %ebx,%edi
 8049f98:	f3 ab                	rep stos %eax,%es:(%edi)
	case 'r':
	    parse_long(optarg, &args->retransmission_timeout, argv[0], 
			    "route_timeout");
	    break;
	case 't':
	    parse_long(optarg, &args->lsa_timeout, argv[0], 
 8049f9a:	31 ff                	xor    %edi,%edi
    int	c, i, found, old_optind;

    /* set defaults for arguments */
    bzero(args, sizeof(rt_args_t));

    args->nodeID = (unsigned long)-1;
 8049f9c:	c7 03 ff ff ff ff    	movl   $0xffffffff,(%ebx)
    
    args->advertisement_cycle_time = 30;
 8049fa2:	c7 83 08 02 00 00 1e 	movl   $0x1e,0x208(%ebx)
 8049fa9:	00 00 00 
    args->neighbor_timeout = 120;
    args->retransmission_timeout = 3;
    args->lsa_timeout = 120;
    
    /* parse command line */
    old_optind = optind;
 8049fac:	a1 88 e1 04 08       	mov    0x804e188,%eax
    bzero(args, sizeof(rt_args_t));

    args->nodeID = (unsigned long)-1;
    
    args->advertisement_cycle_time = 30;
    args->neighbor_timeout = 120;
 8049fb1:	c7 83 0c 02 00 00 78 	movl   $0x78,0x20c(%ebx)
 8049fb8:	00 00 00 
    args->retransmission_timeout = 3;
 8049fbb:	c7 83 10 02 00 00 03 	movl   $0x3,0x210(%ebx)
 8049fc2:	00 00 00 
    args->lsa_timeout = 120;
 8049fc5:	c7 83 14 02 00 00 78 	movl   $0x78,0x214(%ebx)
 8049fcc:	00 00 00 
    
    /* parse command line */
    old_optind = optind;
 8049fcf:	89 45 cc             	mov    %eax,-0x34(%ebp)
	case 'i':
	    parse_long(optarg, &args->nodeID, argv[0], "nodeID");
	    break;
	case 'c':
	    found = 1;
	    rt_parse_config_file(argv[0], &args->config_file, optarg);
 8049fd2:	8d 43 04             	lea    0x4(%ebx),%eax
 8049fd5:	89 45 d0             	mov    %eax,-0x30(%ebp)
	    break;
	case 'G':
	    /* ignore -- this is only for grading */
	    break;
	case 'a':
	    parse_long(optarg, &args->advertisement_cycle_time, argv[0], 
 8049fd8:	8d 83 08 02 00 00    	lea    0x208(%ebx),%eax
 8049fde:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			    "advertisement_cycle_time");
	    break;
	case 'n':
	    parse_long(optarg, &args->neighbor_timeout, argv[0], 
 8049fe1:	8d 83 0c 02 00 00    	lea    0x20c(%ebx),%eax
 8049fe7:	89 45 d8             	mov    %eax,-0x28(%ebp)
			    "neighbor_timeout");
	    break;
	case 'r':
	    parse_long(optarg, &args->retransmission_timeout, argv[0], 
 8049fea:	8d 83 10 02 00 00    	lea    0x210(%ebx),%eax
 8049ff0:	89 45 dc             	mov    %eax,-0x24(%ebp)
			    "route_timeout");
	    break;
	case 't':
	    parse_long(optarg, &args->lsa_timeout, argv[0], 
 8049ff3:	8d 83 14 02 00 00    	lea    0x214(%ebx),%eax
 8049ff9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    args->lsa_timeout = 120;
    
    /* parse command line */
    old_optind = optind;
    found = 0;
    while ((c = getopt(argc, argv, _rt_optstring)) != -1) {
 8049ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049fff:	c7 44 24 08 22 b9 04 	movl   $0x804b922,0x8(%esp)
 804a006:	08 
 804a007:	89 74 24 04          	mov    %esi,0x4(%esp)
 804a00b:	89 04 24             	mov    %eax,(%esp)
 804a00e:	e8 9d f2 ff ff       	call   80492b0 <getopt@plt>
 804a013:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a016:	0f 84 14 01 00 00    	je     804a130 <rt_parse_command_line+0x1b0>
	switch (c) {
 804a01c:	8d 50 c1             	lea    -0x3f(%eax),%edx
 804a01f:	83 fa 35             	cmp    $0x35,%edx
 804a022:	76 3c                	jbe    804a060 <rt_parse_command_line+0xe0>
 804a024:	0f be c0             	movsbl %al,%eax
 804a027:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a02b:	8b 06                	mov    (%esi),%eax
 804a02d:	c7 44 24 08 08 b9 04 	movl   $0x804b908,0x8(%esp)
 804a034:	08 
 804a035:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a03c:	00 
 804a03d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a041:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a046:	89 04 24             	mov    %eax,(%esp)
 804a049:	e8 92 f3 ff ff       	call   80493e0 <__fprintf_chk@plt>
	    break;
	case '?':
	    exit(255);
	default:
	    fprintf(stderr, "%s: unknown argument -%c\n", argv[0], (char)c);
	    exit(255);
 804a04e:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 804a055:	e8 76 f1 ff ff       	call   80491d0 <exit@plt>
 804a05a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    
    /* parse command line */
    old_optind = optind;
    found = 0;
    while ((c = getopt(argc, argv, _rt_optstring)) != -1) {
	switch (c) {
 804a060:	ff 24 95 34 bb 04 08 	jmp    *0x804bb34(,%edx,4)
 804a067:	90                   	nop
	case 'r':
	    parse_long(optarg, &args->retransmission_timeout, argv[0], 
			    "route_timeout");
	    break;
	case 't':
	    parse_long(optarg, &args->lsa_timeout, argv[0], 
 804a068:	c7 04 24 f0 b8 04 08 	movl   $0x804b8f0,(%esp)
 804a06f:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a072:	8b 0e                	mov    (%esi),%ecx
 804a074:	a1 8c e1 04 08       	mov    0x804e18c,%eax
 804a079:	e8 42 fe ff ff       	call   8049ec0 <parse_long>
 804a07e:	e9 79 ff ff ff       	jmp    8049ffc <rt_parse_command_line+0x7c>
 804a083:	90                   	nop
 804a084:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	case 'n':
	    parse_long(optarg, &args->neighbor_timeout, argv[0], 
			    "neighbor_timeout");
	    break;
	case 'r':
	    parse_long(optarg, &args->retransmission_timeout, argv[0], 
 804a088:	c7 04 24 e2 b8 04 08 	movl   $0x804b8e2,(%esp)
 804a08f:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a092:	8b 0e                	mov    (%esi),%ecx
 804a094:	a1 8c e1 04 08       	mov    0x804e18c,%eax
 804a099:	e8 22 fe ff ff       	call   8049ec0 <parse_long>
			    "route_timeout");
	    break;
 804a09e:	e9 59 ff ff ff       	jmp    8049ffc <rt_parse_command_line+0x7c>
 804a0a3:	90                   	nop
 804a0a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	case 'a':
	    parse_long(optarg, &args->advertisement_cycle_time, argv[0], 
			    "advertisement_cycle_time");
	    break;
	case 'n':
	    parse_long(optarg, &args->neighbor_timeout, argv[0], 
 804a0a8:	c7 04 24 d1 b8 04 08 	movl   $0x804b8d1,(%esp)
 804a0af:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a0b2:	8b 0e                	mov    (%esi),%ecx
 804a0b4:	a1 8c e1 04 08       	mov    0x804e18c,%eax
 804a0b9:	e8 02 fe ff ff       	call   8049ec0 <parse_long>
			    "neighbor_timeout");
	    break;
 804a0be:	e9 39 ff ff ff       	jmp    8049ffc <rt_parse_command_line+0x7c>
 804a0c3:	90                   	nop
 804a0c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    old_optind = optind;
    found = 0;
    while ((c = getopt(argc, argv, _rt_optstring)) != -1) {
	switch (c) {
	case 'i':
	    parse_long(optarg, &args->nodeID, argv[0], "nodeID");
 804a0c8:	c7 04 24 b1 b8 04 08 	movl   $0x804b8b1,(%esp)
 804a0cf:	a1 8c e1 04 08       	mov    0x804e18c,%eax
 804a0d4:	89 da                	mov    %ebx,%edx
 804a0d6:	8b 0e                	mov    (%esi),%ecx
 804a0d8:	e8 e3 fd ff ff       	call   8049ec0 <parse_long>
	    break;
 804a0dd:	e9 1a ff ff ff       	jmp    8049ffc <rt_parse_command_line+0x7c>
 804a0e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	case 'c':
	    found = 1;
	    rt_parse_config_file(argv[0], &args->config_file, optarg);
 804a0e8:	a1 8c e1 04 08       	mov    0x804e18c,%eax
 804a0ed:	bf 01 00 00 00       	mov    $0x1,%edi
 804a0f2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a0f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a0f9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a0fd:	8b 06                	mov    (%esi),%eax
 804a0ff:	89 04 24             	mov    %eax,(%esp)
 804a102:	e8 b9 fb ff ff       	call   8049cc0 <rt_parse_config_file>
	    break;
 804a107:	e9 f0 fe ff ff       	jmp    8049ffc <rt_parse_command_line+0x7c>
 804a10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	case 'G':
	    /* ignore -- this is only for grading */
	    break;
	case 'a':
	    parse_long(optarg, &args->advertisement_cycle_time, argv[0], 
 804a110:	c7 04 24 b8 b8 04 08 	movl   $0x804b8b8,(%esp)
 804a117:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804a11a:	8b 0e                	mov    (%esi),%ecx
 804a11c:	a1 8c e1 04 08       	mov    0x804e18c,%eax
 804a121:	e8 9a fd ff ff       	call   8049ec0 <parse_long>
			    "advertisement_cycle_time");
	    break;
 804a126:	e9 d1 fe ff ff       	jmp    8049ffc <rt_parse_command_line+0x7c>
 804a12b:	90                   	nop
 804a12c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	    break;
	}
    }

    /* validate some of the arguments */
    if (args->nodeID == (unsigned long)-1) {
 804a130:	83 3b ff             	cmpl   $0xffffffff,(%ebx)
 804a133:	0f 84 45 01 00 00    	je     804a27e <rt_parse_command_line+0x2fe>
	fprintf(stderr, "%s: nodeID must be specified\n", argv[0]);
	exit(255);
    }
    if (args->neighbor_timeout % args->advertisement_cycle_time != 0) {
 804a139:	8b 83 0c 02 00 00    	mov    0x20c(%ebx),%eax
 804a13f:	31 d2                	xor    %edx,%edx
 804a141:	8b 8b 08 02 00 00    	mov    0x208(%ebx),%ecx
 804a147:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a14a:	f7 f1                	div    %ecx
 804a14c:	85 d2                	test   %edx,%edx
 804a14e:	0f 85 bc 00 00 00    	jne    804a210 <rt_parse_command_line+0x290>
	fprintf(stderr, "%s: warning: neighbor_timeout (%lu) is not a "
		"multiple of advertisement_cycle_time (%lu)\n", argv[0], 
		args->neighbor_timeout, args->advertisement_cycle_time);
    }
    if (args->lsa_timeout % args->advertisement_cycle_time != 0) {
 804a154:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804a15a:	31 d2                	xor    %edx,%edx
 804a15c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a15f:	f7 f1                	div    %ecx
 804a161:	85 d2                	test   %edx,%edx
 804a163:	75 78                	jne    804a1dd <rt_parse_command_line+0x25d>
	fprintf(stderr, "%s: warning: lsa_timeout (%lu) is not a "
		"multiple of advertisement_cycle_time (%lu)\n", argv[0], 
		args->lsa_timeout, args->advertisement_cycle_time);
    }
    if (!found) {
 804a165:	85 ff                	test   %edi,%edi
 804a167:	0f 84 40 01 00 00    	je     804a2ad <rt_parse_command_line+0x32d>
	fprintf(stderr, "%s: you must specify a config_file\n", argv[0]);
	exit(0);
    }
    if (args->config_file.size < 2) {
 804a16d:	8b 4b 04             	mov    0x4(%ebx),%ecx
 804a170:	83 f9 01             	cmp    $0x1,%ecx
 804a173:	0f 8e d0 00 00 00    	jle    804a249 <rt_parse_command_line+0x2c9>
	fprintf(stderr, "%s: warning: this node has no neighbors!\n", argv[0]);
    }
    found = 0;
    for (i=0; i<args->config_file.size; i++) {
	if (args->config_file.entries[i].nodeID == args->nodeID) {
 804a179:	8b 3b                	mov    (%ebx),%edi
 804a17b:	31 c0                	xor    %eax,%eax
 804a17d:	39 7b 08             	cmp    %edi,0x8(%ebx)
 804a180:	75 11                	jne    804a193 <rt_parse_command_line+0x213>
 804a182:	eb 49                	jmp    804a1cd <rt_parse_command_line+0x24d>
 804a184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804a188:	89 c2                	mov    %eax,%edx
 804a18a:	c1 e2 04             	shl    $0x4,%edx
 804a18d:	3b 7c 13 08          	cmp    0x8(%ebx,%edx,1),%edi
 804a191:	74 3a                	je     804a1cd <rt_parse_command_line+0x24d>
    }
    if (args->config_file.size < 2) {
	fprintf(stderr, "%s: warning: this node has no neighbors!\n", argv[0]);
    }
    found = 0;
    for (i=0; i<args->config_file.size; i++) {
 804a193:	83 c0 01             	add    $0x1,%eax
 804a196:	39 c8                	cmp    %ecx,%eax
 804a198:	7c ee                	jl     804a188 <rt_parse_command_line+0x208>
 804a19a:	89 7c 24 10          	mov    %edi,0x10(%esp)
 804a19e:	8b 06                	mov    (%esi),%eax
 804a1a0:	c7 44 24 08 f8 ba 04 	movl   $0x804baf8,0x8(%esp)
 804a1a7:	08 
 804a1a8:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a1af:	00 
 804a1b0:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a1b4:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a1b9:	89 04 24             	mov    %eax,(%esp)
 804a1bc:	e8 1f f2 ff ff       	call   80493e0 <__fprintf_chk@plt>
	}
    }
    if (!found) {
	fprintf(stderr, "%s: this node's nodeID (%lu) wasn't in the "
		"config file!\n", argv[0], args->nodeID);
	exit(255);
 804a1c1:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 804a1c8:	e8 03 f0 ff ff       	call   80491d0 <exit@plt>
    }

    /* reset optind in case the caller wants to getopt some more */
    optind = old_optind;
 804a1cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a1d0:	a3 88 e1 04 08       	mov    %eax,0x804e188
}
 804a1d5:	83 c4 4c             	add    $0x4c,%esp
 804a1d8:	5b                   	pop    %ebx
 804a1d9:	5e                   	pop    %esi
 804a1da:	5f                   	pop    %edi
 804a1db:	5d                   	pop    %ebp
 804a1dc:	c3                   	ret    
 804a1dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a1e0:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804a1e4:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a1e8:	8b 06                	mov    (%esi),%eax
 804a1ea:	c7 44 24 08 54 ba 04 	movl   $0x804ba54,0x8(%esp)
 804a1f1:	08 
 804a1f2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a1f9:	00 
 804a1fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a1fe:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a203:	89 04 24             	mov    %eax,(%esp)
 804a206:	e8 d5 f1 ff ff       	call   80493e0 <__fprintf_chk@plt>
 804a20b:	e9 55 ff ff ff       	jmp    804a165 <rt_parse_command_line+0x1e5>
 804a210:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a213:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804a217:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a21b:	8b 06                	mov    (%esi),%eax
 804a21d:	c7 44 24 08 f8 b9 04 	movl   $0x804b9f8,0x8(%esp)
 804a224:	08 
 804a225:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a22c:	00 
 804a22d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a231:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a236:	89 04 24             	mov    %eax,(%esp)
 804a239:	e8 a2 f1 ff ff       	call   80493e0 <__fprintf_chk@plt>
 804a23e:	8b 8b 08 02 00 00    	mov    0x208(%ebx),%ecx
 804a244:	e9 0b ff ff ff       	jmp    804a154 <rt_parse_command_line+0x1d4>
 804a249:	8b 06                	mov    (%esi),%eax
 804a24b:	c7 44 24 08 cc ba 04 	movl   $0x804bacc,0x8(%esp)
 804a252:	08 
 804a253:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a25a:	00 
 804a25b:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a25f:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a264:	89 04 24             	mov    %eax,(%esp)
 804a267:	e8 74 f1 ff ff       	call   80493e0 <__fprintf_chk@plt>
 804a26c:	8b 4b 04             	mov    0x4(%ebx),%ecx
    }
    if (args->config_file.size < 2) {
	fprintf(stderr, "%s: warning: this node has no neighbors!\n", argv[0]);
    }
    found = 0;
    for (i=0; i<args->config_file.size; i++) {
 804a26f:	85 c9                	test   %ecx,%ecx
 804a271:	0f 8f 02 ff ff ff    	jg     804a179 <rt_parse_command_line+0x1f9>
	exit(255);
    }

    /* reset optind in case the caller wants to getopt some more */
    optind = old_optind;
}
 804a277:	8b 3b                	mov    (%ebx),%edi
 804a279:	e9 1c ff ff ff       	jmp    804a19a <rt_parse_command_line+0x21a>
 804a27e:	8b 06                	mov    (%esi),%eax
 804a280:	c7 44 24 08 39 b9 04 	movl   $0x804b939,0x8(%esp)
 804a287:	08 
 804a288:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a28f:	00 
 804a290:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a294:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a299:	89 04 24             	mov    %eax,(%esp)
 804a29c:	e8 3f f1 ff ff       	call   80493e0 <__fprintf_chk@plt>
    }

    /* validate some of the arguments */
    if (args->nodeID == (unsigned long)-1) {
	fprintf(stderr, "%s: nodeID must be specified\n", argv[0]);
	exit(255);
 804a2a1:	c7 04 24 ff 00 00 00 	movl   $0xff,(%esp)
 804a2a8:	e8 23 ef ff ff       	call   80491d0 <exit@plt>
 804a2ad:	8b 06                	mov    (%esi),%eax
 804a2af:	c7 44 24 08 a8 ba 04 	movl   $0x804baa8,0x8(%esp)
 804a2b6:	08 
 804a2b7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a2be:	00 
 804a2bf:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a2c3:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a2c8:	89 04 24             	mov    %eax,(%esp)
 804a2cb:	e8 10 f1 ff ff       	call   80493e0 <__fprintf_chk@plt>
		"multiple of advertisement_cycle_time (%lu)\n", argv[0], 
		args->lsa_timeout, args->advertisement_cycle_time);
    }
    if (!found) {
	fprintf(stderr, "%s: you must specify a config_file\n", argv[0]);
	exit(0);
 804a2d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a2d7:	e8 f4 ee ff ff       	call   80491d0 <exit@plt>
 804a2dc:	66 90                	xchg   %ax,%ax
 804a2de:	66 90                	xchg   %ax,%ax

0804a2e0 <rt_init>:
#include <sys/types.h>
#include <sys/socket.h>
#include "rtgrading.h"

void rt_init(int argc, char **argv)
{
 804a2e0:	55                   	push   %ebp
 804a2e1:	89 e5                	mov    %esp,%ebp
    return;
}
 804a2e3:	5d                   	pop    %ebp
 804a2e4:	c3                   	ret    
 804a2e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804a2e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a2f0 <rt_recvfrom>:
    return sendto(s, msg, len, flags, to, tolen);
}

int rt_recvfrom(int  s,  void  *buf,  size_t len, int flags,
		struct sockaddr *from, socklen_t *fromlen)
{
 804a2f0:	55                   	push   %ebp
 804a2f1:	89 e5                	mov    %esp,%ebp
 804a2f3:	83 ec 08             	sub    $0x8,%esp
    return recvfrom(s, buf, len, flags, from, fromlen);
}
 804a2f6:	c9                   	leave  
			       __addr, __addr_len);
      if (__n > __bos0 (__buf))
	return __recvfrom_chk_warn (__fd, __buf, __n, __bos0 (__buf), __flags,
				    __addr, __addr_len);
    }
  return __recvfrom_alias (__fd, __buf, __n, __flags, __addr, __addr_len);
 804a2f7:	e9 74 ed ff ff       	jmp    8049070 <recvfrom@plt>
 804a2fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a300 <rt_sendto>:
    return;
}

int rt_sendto(int s, const void *msg, size_t len, int flags,
	      const struct sockaddr *to, socklen_t tolen)
{
 804a300:	55                   	push   %ebp
 804a301:	89 e5                	mov    %esp,%ebp
 804a303:	83 ec 08             	sub    $0x8,%esp
    return sendto(s, msg, len, flags, to, tolen);
}
 804a306:	c9                   	leave  
}

int rt_sendto(int s, const void *msg, size_t len, int flags,
	      const struct sockaddr *to, socklen_t tolen)
{
    return sendto(s, msg, len, flags, to, tolen);
 804a307:	e9 54 f0 ff ff       	jmp    8049360 <sendto@plt>
 804a30c:	66 90                	xchg   %ax,%ax
 804a30e:	66 90                	xchg   %ax,%ax

0804a310 <rio_readinitb>:
/*
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd) 
{
 804a310:	55                   	push   %ebp
 804a311:	89 e5                	mov    %esp,%ebp
 804a313:	8b 45 08             	mov    0x8(%ebp),%eax
    rp->rio_fd = fd;  
 804a316:	8b 55 0c             	mov    0xc(%ebp),%edx
    rp->rio_cnt = 0;  
 804a319:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd) 
{
    rp->rio_fd = fd;  
 804a320:	89 10                	mov    %edx,(%eax)
    rp->rio_cnt = 0;  
    rp->rio_bufptr = rp->rio_buf;
 804a322:	8d 50 0c             	lea    0xc(%eax),%edx
 804a325:	89 50 08             	mov    %edx,0x8(%eax)
}
 804a328:	5d                   	pop    %ebp
 804a329:	c3                   	ret    
 804a32a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804a330 <Rio_readinitb>:
    if (rio_writen(fd, usrbuf, n) != n)
	unix_error("Rio_writen error");
}

void Rio_readinitb(rio_t *rp, int fd)
{
 804a330:	55                   	push   %ebp
 804a331:	89 e5                	mov    %esp,%ebp
 804a333:	8b 45 08             	mov    0x8(%ebp),%eax
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd) 
{
    rp->rio_fd = fd;  
 804a336:	8b 55 0c             	mov    0xc(%ebp),%edx
    rp->rio_cnt = 0;  
 804a339:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd) 
{
    rp->rio_fd = fd;  
 804a340:	89 10                	mov    %edx,(%eax)
    rp->rio_cnt = 0;  
    rp->rio_bufptr = rp->rio_buf;
 804a342:	8d 50 0c             	lea    0xc(%eax),%edx
 804a345:	89 50 08             	mov    %edx,0x8(%eax)
}

void Rio_readinitb(rio_t *rp, int fd)
{
    rio_readinitb(rp, fd);
} 
 804a348:	5d                   	pop    %ebp
 804a349:	c3                   	ret    
 804a34a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804a350 <rio_readn>:
/*
 * rio_readn - robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
 804a350:	55                   	push   %ebp
 804a351:	89 e5                	mov    %esp,%ebp
 804a353:	57                   	push   %edi
 804a354:	56                   	push   %esi
 804a355:	53                   	push   %ebx
 804a356:	83 ec 1c             	sub    $0x1c,%esp
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
 804a359:	8b 45 10             	mov    0x10(%ebp),%eax
/*
 * rio_readn - robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
 804a35c:	8b 7d 08             	mov    0x8(%ebp),%edi
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
 804a35f:	85 c0                	test   %eax,%eax
 804a361:	74 4f                	je     804a3b2 <rio_readn+0x62>
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;
 804a363:	8b 75 0c             	mov    0xc(%ebp),%esi
 804a366:	8b 5d 10             	mov    0x10(%ebp),%ebx
 804a369:	eb 0b                	jmp    804a376 <rio_readn+0x26>
 804a36b:	90                   	nop
 804a36c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    while (nleft > 0) {
 804a370:	29 c3                	sub    %eax,%ebx
 804a372:	74 19                	je     804a38d <rio_readn+0x3d>
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
 804a374:	01 c6                	add    %eax,%esi
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
 804a376:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 804a37a:	89 74 24 04          	mov    %esi,0x4(%esp)
 804a37e:	89 3c 24             	mov    %edi,(%esp)
 804a381:	e8 0a ec ff ff       	call   8048f90 <read@plt>
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nread = read(fd, bufp, nleft)) < 0) {
 804a386:	83 f8 00             	cmp    $0x0,%eax
 804a389:	7c 15                	jl     804a3a0 <rio_readn+0x50>
	    if (errno == EINTR) /* interrupted by sig handler return */
		nread = 0;      /* and call read() again */
	    else
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
 804a38b:	75 e3                	jne    804a370 <rio_readn+0x20>
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
    }
    return (n - nleft);         /* return >= 0 */
 804a38d:	8b 45 10             	mov    0x10(%ebp),%eax
 804a390:	29 d8                	sub    %ebx,%eax
}
 804a392:	83 c4 1c             	add    $0x1c,%esp
 804a395:	5b                   	pop    %ebx
 804a396:	5e                   	pop    %esi
 804a397:	5f                   	pop    %edi
 804a398:	5d                   	pop    %ebp
 804a399:	c3                   	ret    
 804a39a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nread = read(fd, bufp, nleft)) < 0) {
	    if (errno == EINTR) /* interrupted by sig handler return */
 804a3a0:	e8 7b ef ff ff       	call   8049320 <__errno_location@plt>
 804a3a5:	83 38 04             	cmpl   $0x4,(%eax)
 804a3a8:	75 0c                	jne    804a3b6 <rio_readn+0x66>
 804a3aa:	31 c0                	xor    %eax,%eax
 804a3ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804a3b0:	eb be                	jmp    804a370 <rio_readn+0x20>
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
 804a3b2:	31 db                	xor    %ebx,%ebx
 804a3b4:	eb d7                	jmp    804a38d <rio_readn+0x3d>
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nread = read(fd, bufp, nleft)) < 0) {
	    if (errno == EINTR) /* interrupted by sig handler return */
 804a3b6:	83 c8 ff             	or     $0xffffffff,%eax
 804a3b9:	eb d7                	jmp    804a392 <rio_readn+0x42>
 804a3bb:	90                   	nop
 804a3bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a3c0 <rio_read>:
 *    entry, rio_read() refills the internal buffer via a call to
 *    read() if the internal buffer is empty.
 */
/* $begin rio_read */
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
 804a3c0:	55                   	push   %ebp
 804a3c1:	89 e5                	mov    %esp,%ebp
 804a3c3:	57                   	push   %edi
 804a3c4:	56                   	push   %esi
 804a3c5:	53                   	push   %ebx
 804a3c6:	89 c3                	mov    %eax,%ebx
 804a3c8:	83 ec 2c             	sub    $0x2c,%esp
    int cnt;

    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
 804a3cb:	8d 78 0c             	lea    0xc(%eax),%edi
 *    entry, rio_read() refills the internal buffer via a call to
 *    read() if the internal buffer is empty.
 */
/* $begin rio_read */
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
 804a3ce:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804a3d1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    int cnt;

    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
 804a3d4:	eb 25                	jmp    804a3fb <rio_read+0x3b>
 804a3d6:	66 90                	xchg   %ax,%ax
 804a3d8:	c7 44 24 08 00 20 00 	movl   $0x2000,0x8(%esp)
 804a3df:	00 
 804a3e0:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804a3e4:	8b 03                	mov    (%ebx),%eax
 804a3e6:	89 04 24             	mov    %eax,(%esp)
 804a3e9:	e8 a2 eb ff ff       	call   8048f90 <read@plt>
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
 804a3ee:	83 f8 00             	cmp    $0x0,%eax
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;

    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
 804a3f1:	89 43 04             	mov    %eax,0x4(%ebx)
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
 804a3f4:	7c 52                	jl     804a448 <rio_read+0x88>
	    if (errno != EINTR) /* interrupted by sig handler return */
		return -1;
	}
	else if (rp->rio_cnt == 0)  /* EOF */
 804a3f6:	74 40                	je     804a438 <rio_read+0x78>
	    return 0;
	else 
	    rp->rio_bufptr = rp->rio_buf; /* reset buffer ptr */
 804a3f8:	89 7b 08             	mov    %edi,0x8(%ebx)
/* $begin rio_read */
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;

    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
 804a3fb:	8b 73 04             	mov    0x4(%ebx),%esi
 804a3fe:	85 f6                	test   %esi,%esi
 804a400:	7e d6                	jle    804a3d8 <rio_read+0x18>
	    rp->rio_bufptr = rp->rio_buf; /* reset buffer ptr */
    }

    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    cnt = n;          
    if (rp->rio_cnt < n)   
 804a402:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
 804a405:	89 f7                	mov    %esi,%edi
 804a407:	76 27                	jbe    804a430 <rio_read+0x70>

__extern_always_inline void *
__NTH (memcpy (void *__restrict __dest, __const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 804a409:	8b 43 08             	mov    0x8(%ebx),%eax
 804a40c:	89 7c 24 08          	mov    %edi,0x8(%esp)
 804a410:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a414:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a417:	89 04 24             	mov    %eax,(%esp)
 804a41a:	e8 c1 eb ff ff       	call   8048fe0 <memcpy@plt>
	cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
 804a41f:	01 7b 08             	add    %edi,0x8(%ebx)
    rp->rio_cnt -= cnt;
 804a422:	29 73 04             	sub    %esi,0x4(%ebx)
    return cnt;
}
 804a425:	83 c4 2c             	add    $0x2c,%esp
 804a428:	89 f0                	mov    %esi,%eax
 804a42a:	5b                   	pop    %ebx
 804a42b:	5e                   	pop    %esi
 804a42c:	5f                   	pop    %edi
 804a42d:	5d                   	pop    %ebp
 804a42e:	c3                   	ret    
 804a42f:	90                   	nop
	else 
	    rp->rio_bufptr = rp->rio_buf; /* reset buffer ptr */
    }

    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    cnt = n;          
 804a430:	8b 75 e4             	mov    -0x1c(%ebp),%esi
 804a433:	89 f7                	mov    %esi,%edi
 804a435:	eb d2                	jmp    804a409 <rio_read+0x49>
 804a437:	90                   	nop
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
	    if (errno != EINTR) /* interrupted by sig handler return */
		return -1;
	}
	else if (rp->rio_cnt == 0)  /* EOF */
 804a438:	31 f6                	xor    %esi,%esi
	cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
 804a43a:	83 c4 2c             	add    $0x2c,%esp
 804a43d:	89 f0                	mov    %esi,%eax
 804a43f:	5b                   	pop    %ebx
 804a440:	5e                   	pop    %esi
 804a441:	5f                   	pop    %edi
 804a442:	5d                   	pop    %ebp
 804a443:	c3                   	ret    
 804a444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

    while (rp->rio_cnt <= 0) {  /* refill if buf is empty */
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
	    if (errno != EINTR) /* interrupted by sig handler return */
 804a448:	e8 d3 ee ff ff       	call   8049320 <__errno_location@plt>
 804a44d:	83 38 04             	cmpl   $0x4,(%eax)
 804a450:	74 a9                	je     804a3fb <rio_read+0x3b>
 804a452:	83 ce ff             	or     $0xffffffff,%esi
 804a455:	eb ce                	jmp    804a425 <rio_read+0x65>
 804a457:	89 f6                	mov    %esi,%esi
 804a459:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a460 <rio_readlineb>:
/* 
 * rio_readlineb - robustly read a text line (buffered)
 */
/* $begin rio_readlineb */
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
 804a460:	55                   	push   %ebp
 804a461:	89 e5                	mov    %esp,%ebp
 804a463:	57                   	push   %edi
 804a464:	56                   	push   %esi
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n < maxlen; n++) { 
 804a465:	be 01 00 00 00       	mov    $0x1,%esi
/* 
 * rio_readlineb - robustly read a text line (buffered)
 */
/* $begin rio_readlineb */
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
 804a46a:	53                   	push   %ebx
 804a46b:	83 ec 1c             	sub    $0x1c,%esp
    int n, rc;
    char c, *bufp = usrbuf;
 804a46e:	8b 5d 0c             	mov    0xc(%ebp),%ebx

    for (n = 1; n < maxlen; n++) { 
 804a471:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804a475:	8d 7d e7             	lea    -0x19(%ebp),%edi
 804a478:	77 1d                	ja     804a497 <rio_readlineb+0x37>
 804a47a:	eb 3c                	jmp    804a4b8 <rio_readlineb+0x58>
 804a47c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if ((rc = rio_read(rp, &c, 1)) == 1) {
	    *bufp++ = c;
 804a480:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
 804a484:	88 03                	mov    %al,(%ebx)
 804a486:	83 c3 01             	add    $0x1,%ebx
	    if (c == '\n')
 804a489:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
 804a48d:	74 29                	je     804a4b8 <rio_readlineb+0x58>
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n < maxlen; n++) { 
 804a48f:	83 c6 01             	add    $0x1,%esi
 804a492:	3b 75 10             	cmp    0x10(%ebp),%esi
 804a495:	73 21                	jae    804a4b8 <rio_readlineb+0x58>
	if ((rc = rio_read(rp, &c, 1)) == 1) {
 804a497:	8b 45 08             	mov    0x8(%ebp),%eax
 804a49a:	b9 01 00 00 00       	mov    $0x1,%ecx
 804a49f:	89 fa                	mov    %edi,%edx
 804a4a1:	e8 1a ff ff ff       	call   804a3c0 <rio_read>
 804a4a6:	83 f8 01             	cmp    $0x1,%eax
 804a4a9:	74 d5                	je     804a480 <rio_readlineb+0x20>
	    *bufp++ = c;
	    if (c == '\n')
		break;
	} else if (rc == 0) {
 804a4ab:	85 c0                	test   %eax,%eax
 804a4ad:	75 19                	jne    804a4c8 <rio_readlineb+0x68>
	    if (n == 1)
 804a4af:	83 fe 01             	cmp    $0x1,%esi
 804a4b2:	74 23                	je     804a4d7 <rio_readlineb+0x77>
 804a4b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	    else
		break;    /* EOF, some data was read */
	} else
	    return -1;	  /* error */
    }
    *bufp = 0;
 804a4b8:	c6 03 00             	movb   $0x0,(%ebx)
    return n;
}
 804a4bb:	83 c4 1c             	add    $0x1c,%esp
 804a4be:	89 f0                	mov    %esi,%eax
 804a4c0:	5b                   	pop    %ebx
 804a4c1:	5e                   	pop    %esi
 804a4c2:	5f                   	pop    %edi
 804a4c3:	5d                   	pop    %ebp
 804a4c4:	c3                   	ret    
 804a4c5:	8d 76 00             	lea    0x0(%esi),%esi
    for (n = 1; n < maxlen; n++) { 
	if ((rc = rio_read(rp, &c, 1)) == 1) {
	    *bufp++ = c;
	    if (c == '\n')
		break;
	} else if (rc == 0) {
 804a4c8:	be ff ff ff ff       	mov    $0xffffffff,%esi
	} else
	    return -1;	  /* error */
    }
    *bufp = 0;
    return n;
}
 804a4cd:	83 c4 1c             	add    $0x1c,%esp
 804a4d0:	89 f0                	mov    %esi,%eax
 804a4d2:	5b                   	pop    %ebx
 804a4d3:	5e                   	pop    %esi
 804a4d4:	5f                   	pop    %edi
 804a4d5:	5d                   	pop    %ebp
 804a4d6:	c3                   	ret    
	if ((rc = rio_read(rp, &c, 1)) == 1) {
	    *bufp++ = c;
	    if (c == '\n')
		break;
	} else if (rc == 0) {
	    if (n == 1)
 804a4d7:	66 31 f6             	xor    %si,%si
 804a4da:	eb df                	jmp    804a4bb <rio_readlineb+0x5b>
 804a4dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a4e0 <rio_readnb>:
/*
 * rio_readnb - Robustly read n bytes (buffered)
 */
/* $begin rio_readnb */
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
 804a4e0:	55                   	push   %ebp
 804a4e1:	89 e5                	mov    %esp,%ebp
 804a4e3:	57                   	push   %edi
 804a4e4:	56                   	push   %esi
 804a4e5:	53                   	push   %ebx
 804a4e6:	83 ec 0c             	sub    $0xc,%esp
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;
    
    while (nleft > 0) {
 804a4e9:	8b 55 10             	mov    0x10(%ebp),%edx
/*
 * rio_readnb - Robustly read n bytes (buffered)
 */
/* $begin rio_readnb */
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
 804a4ec:	8b 7d 08             	mov    0x8(%ebp),%edi
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;
    
    while (nleft > 0) {
 804a4ef:	85 d2                	test   %edx,%edx
 804a4f1:	74 43                	je     804a536 <rio_readnb+0x56>
/* $begin rio_readnb */
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;
 804a4f3:	8b 75 0c             	mov    0xc(%ebp),%esi
 804a4f6:	8b 5d 10             	mov    0x10(%ebp),%ebx
 804a4f9:	eb 0b                	jmp    804a506 <rio_readnb+0x26>
 804a4fb:	90                   	nop
 804a4fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    
    while (nleft > 0) {
 804a500:	29 c3                	sub    %eax,%ebx
 804a502:	74 14                	je     804a518 <rio_readnb+0x38>
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
 804a504:	01 c6                	add    %eax,%esi
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;
    
    while (nleft > 0) {
	if ((nread = rio_read(rp, bufp, nleft)) < 0) {
 804a506:	89 d9                	mov    %ebx,%ecx
 804a508:	89 f2                	mov    %esi,%edx
 804a50a:	89 f8                	mov    %edi,%eax
 804a50c:	e8 af fe ff ff       	call   804a3c0 <rio_read>
 804a511:	83 f8 00             	cmp    $0x0,%eax
 804a514:	7c 12                	jl     804a528 <rio_readnb+0x48>
	    if (errno == EINTR) /* interrupted by sig handler return */
		nread = 0;      /* call read() again */
	    else
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
 804a516:	75 e8                	jne    804a500 <rio_readnb+0x20>
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
    }
    return (n - nleft);         /* return >= 0 */
 804a518:	8b 45 10             	mov    0x10(%ebp),%eax
 804a51b:	29 d8                	sub    %ebx,%eax
}
 804a51d:	83 c4 0c             	add    $0xc,%esp
 804a520:	5b                   	pop    %ebx
 804a521:	5e                   	pop    %esi
 804a522:	5f                   	pop    %edi
 804a523:	5d                   	pop    %ebp
 804a524:	c3                   	ret    
 804a525:	8d 76 00             	lea    0x0(%esi),%esi
    ssize_t nread;
    char *bufp = usrbuf;
    
    while (nleft > 0) {
	if ((nread = rio_read(rp, bufp, nleft)) < 0) {
	    if (errno == EINTR) /* interrupted by sig handler return */
 804a528:	e8 f3 ed ff ff       	call   8049320 <__errno_location@plt>
 804a52d:	83 38 04             	cmpl   $0x4,(%eax)
 804a530:	75 08                	jne    804a53a <rio_readnb+0x5a>
 804a532:	31 c0                	xor    %eax,%eax
 804a534:	eb ca                	jmp    804a500 <rio_readnb+0x20>
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
 804a536:	31 db                	xor    %ebx,%ebx
 804a538:	eb de                	jmp    804a518 <rio_readnb+0x38>
    ssize_t nread;
    char *bufp = usrbuf;
    
    while (nleft > 0) {
	if ((nread = rio_read(rp, bufp, nleft)) < 0) {
	    if (errno == EINTR) /* interrupted by sig handler return */
 804a53a:	83 c8 ff             	or     $0xffffffff,%eax
 804a53d:	8d 76 00             	lea    0x0(%esi),%esi
 804a540:	eb db                	jmp    804a51d <rio_readnb+0x3d>
 804a542:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804a549:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a550 <rio_writen>:
/*
 * rio_writen - robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
{
 804a550:	55                   	push   %ebp
 804a551:	89 e5                	mov    %esp,%ebp
 804a553:	57                   	push   %edi
 804a554:	56                   	push   %esi
 804a555:	53                   	push   %ebx
 804a556:	83 ec 1c             	sub    $0x1c,%esp
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
 804a559:	8b 4d 10             	mov    0x10(%ebp),%ecx
/*
 * rio_writen - robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
{
 804a55c:	8b 7d 08             	mov    0x8(%ebp),%edi
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
 804a55f:	85 c9                	test   %ecx,%ecx
 804a561:	74 27                	je     804a58a <rio_writen+0x3a>
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;
 804a563:	8b 75 0c             	mov    0xc(%ebp),%esi
 804a566:	8b 5d 10             	mov    0x10(%ebp),%ebx
 804a569:	eb 07                	jmp    804a572 <rio_writen+0x22>
 804a56b:	90                   	nop
 804a56c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		nwritten = 0;    /* and call write() again */
	    else
		return -1;       /* errorno set by write() */
	}
	nleft -= nwritten;
	bufp += nwritten;
 804a570:	01 c6                	add    %eax,%esi
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nwritten = write(fd, bufp, nleft)) <= 0) {
 804a572:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 804a576:	89 74 24 04          	mov    %esi,0x4(%esp)
 804a57a:	89 3c 24             	mov    %edi,(%esp)
 804a57d:	e8 0e ed ff ff       	call   8049290 <write@plt>
 804a582:	85 c0                	test   %eax,%eax
 804a584:	7e 12                	jle    804a598 <rio_writen+0x48>
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
 804a586:	29 c3                	sub    %eax,%ebx
 804a588:	75 e6                	jne    804a570 <rio_writen+0x20>
		return -1;       /* errorno set by write() */
	}
	nleft -= nwritten;
	bufp += nwritten;
    }
    return n;
 804a58a:	8b 45 10             	mov    0x10(%ebp),%eax
}
 804a58d:	83 c4 1c             	add    $0x1c,%esp
 804a590:	5b                   	pop    %ebx
 804a591:	5e                   	pop    %esi
 804a592:	5f                   	pop    %edi
 804a593:	5d                   	pop    %ebp
 804a594:	c3                   	ret    
 804a595:	8d 76 00             	lea    0x0(%esi),%esi
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nwritten = write(fd, bufp, nleft)) <= 0) {
	    if (errno == EINTR)  /* interrupted by sig handler return */
 804a598:	e8 83 ed ff ff       	call   8049320 <__errno_location@plt>
 804a59d:	83 38 04             	cmpl   $0x4,(%eax)
 804a5a0:	75 04                	jne    804a5a6 <rio_writen+0x56>
 804a5a2:	31 c0                	xor    %eax,%eax
 804a5a4:	eb e0                	jmp    804a586 <rio_writen+0x36>
 804a5a6:	83 c8 ff             	or     $0xffffffff,%eax
 804a5a9:	eb e2                	jmp    804a58d <rio_writen+0x3d>
 804a5ab:	90                   	nop
 804a5ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a5b0 <Pthread_once>:

pthread_t Pthread_self(void) {
    return pthread_self();
}
 
void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {
 804a5b0:	55                   	push   %ebp
 804a5b1:	89 e5                	mov    %esp,%ebp
 804a5b3:	83 ec 08             	sub    $0x8,%esp
    pthread_once(once_control, init_function);
}
 804a5b6:	c9                   	leave  
pthread_t Pthread_self(void) {
    return pthread_self();
}
 
void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {
    pthread_once(once_control, init_function);
 804a5b7:	e9 24 ec ff ff       	jmp    80491e0 <pthread_once@plt>
 804a5bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a5c0 <Pthread_self>:

void Pthread_exit(void *retval) {
    pthread_exit(retval);
}

pthread_t Pthread_self(void) {
 804a5c0:	55                   	push   %ebp
 804a5c1:	89 e5                	mov    %esp,%ebp
 804a5c3:	83 ec 08             	sub    $0x8,%esp
    return pthread_self();
}
 804a5c6:	c9                   	leave  
void Pthread_exit(void *retval) {
    pthread_exit(retval);
}

pthread_t Pthread_self(void) {
    return pthread_self();
 804a5c7:	e9 24 ea ff ff       	jmp    8048ff0 <pthread_self@plt>
 804a5cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a5d0 <Pthread_exit>:
    if ((rc = pthread_detach(tid)) != 0)
	posix_error(rc, "Pthread_detach error");
}
/* $end detach */

void Pthread_exit(void *retval) {
 804a5d0:	55                   	push   %ebp
 804a5d1:	89 e5                	mov    %esp,%ebp
 804a5d3:	83 ec 18             	sub    $0x18,%esp
    pthread_exit(retval);
 804a5d6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a5d9:	89 04 24             	mov    %eax,(%esp)
 804a5dc:	e8 5f ed ff ff       	call   8049340 <pthread_exit@plt>
 804a5e1:	eb 0d                	jmp    804a5f0 <Free>
 804a5e3:	90                   	nop
 804a5e4:	90                   	nop
 804a5e5:	90                   	nop
 804a5e6:	90                   	nop
 804a5e7:	90                   	nop
 804a5e8:	90                   	nop
 804a5e9:	90                   	nop
 804a5ea:	90                   	nop
 804a5eb:	90                   	nop
 804a5ec:	90                   	nop
 804a5ed:	90                   	nop
 804a5ee:	90                   	nop
 804a5ef:	90                   	nop

0804a5f0 <Free>:
    }
    return p;
}

void Free(void *ptr) 
{
 804a5f0:	55                   	push   %ebp
 804a5f1:	89 e5                	mov    %esp,%ebp
 804a5f3:	83 ec 08             	sub    $0x8,%esp
    free(ptr);
}
 804a5f6:	c9                   	leave  
    return p;
}

void Free(void *ptr) 
{
    free(ptr);
 804a5f7:	e9 d4 e9 ff ff       	jmp    8048fd0 <free@plt>
 804a5fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a600 <Getpgrp>:
    if ((rc = setpgid(pid, pgid)) < 0)
	unix_error("Setpgid error");
    return;
}

pid_t Getpgrp(void) {
 804a600:	55                   	push   %ebp
 804a601:	89 e5                	mov    %esp,%ebp
 804a603:	83 ec 08             	sub    $0x8,%esp
    return getpgrp();
}
 804a606:	c9                   	leave  
	unix_error("Setpgid error");
    return;
}

pid_t Getpgrp(void) {
    return getpgrp();
 804a607:	e9 a4 ea ff ff       	jmp    80490b0 <getpgrp@plt>
 804a60c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a610 <Alarm>:
    if ((rc = sleep(secs)) < 0)
	unix_error("Sleep error");
    return rc;
}

unsigned int Alarm(unsigned int seconds) {
 804a610:	55                   	push   %ebp
 804a611:	89 e5                	mov    %esp,%ebp
 804a613:	83 ec 08             	sub    $0x8,%esp
    return alarm(seconds);
}
 804a616:	c9                   	leave  
	unix_error("Sleep error");
    return rc;
}

unsigned int Alarm(unsigned int seconds) {
    return alarm(seconds);
 804a617:	e9 44 ea ff ff       	jmp    8049060 <alarm@plt>
 804a61c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a620 <Sleep>:
    (void)pause();
    return;
}

unsigned int Sleep(unsigned int secs) 
{
 804a620:	55                   	push   %ebp
 804a621:	89 e5                	mov    %esp,%ebp
 804a623:	83 ec 08             	sub    $0x8,%esp
    unsigned int rc;

    if ((rc = sleep(secs)) < 0)
	unix_error("Sleep error");
    return rc;
}
 804a626:	c9                   	leave  

unsigned int Sleep(unsigned int secs) 
{
    unsigned int rc;

    if ((rc = sleep(secs)) < 0)
 804a627:	e9 14 ea ff ff       	jmp    8049040 <sleep@plt>
 804a62c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a630 <Pause>:
	unix_error("Kill error");
}
/* $end kill */

void Pause() 
{
 804a630:	55                   	push   %ebp
 804a631:	89 e5                	mov    %esp,%ebp
 804a633:	83 ec 08             	sub    $0x8,%esp
    (void)pause();
    return;
}
 804a636:	c9                   	leave  
}
/* $end kill */

void Pause() 
{
    (void)pause();
 804a637:	e9 64 e9 ff ff       	jmp    8048fa0 <pause@plt>
 804a63c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a640 <app_error>:
    fprintf(stderr, "%s: DNS error %d\n", msg, h_errno);
    exit(0);
}

void app_error(char *msg) /* application error */
{
 804a640:	55                   	push   %ebp
 804a641:	89 e5                	mov    %esp,%ebp
 804a643:	83 ec 18             	sub    $0x18,%esp
 804a646:	8b 45 08             	mov    0x8(%ebp),%eax
 804a649:	c7 44 24 08 56 bc 04 	movl   $0x804bc56,0x8(%esp)
 804a650:	08 
 804a651:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a658:	00 
 804a659:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a65d:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a662:	89 04 24             	mov    %eax,(%esp)
 804a665:	e8 76 ed ff ff       	call   80493e0 <__fprintf_chk@plt>
    fprintf(stderr, "%s\n", msg);
    exit(0);
 804a66a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a671:	e8 5a eb ff ff       	call   80491d0 <exit@plt>
 804a676:	8d 76 00             	lea    0x0(%esi),%esi
 804a679:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a680 <Fgets>:

    return fp;
}

char *Fgets(char *ptr, int n, FILE *stream) 
{
 804a680:	55                   	push   %ebp
 804a681:	89 e5                	mov    %esp,%ebp
 804a683:	83 ec 18             	sub    $0x18,%esp
	return __fgets_chk (__s, __bos (__s), __n, __stream);

      if ((size_t) __n > __bos (__s))
	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
 804a686:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a689:	89 75 fc             	mov    %esi,-0x4(%ebp)
 804a68c:	8b 75 10             	mov    0x10(%ebp),%esi
 804a68f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
 804a692:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a696:	8b 45 08             	mov    0x8(%ebp),%eax
 804a699:	89 74 24 08          	mov    %esi,0x8(%esp)
 804a69d:	89 04 24             	mov    %eax,(%esp)
 804a6a0:	e8 6b e9 ff ff       	call   8049010 <fgets@plt>
    char *rptr;

    if (((rptr = fgets(ptr, n, stream)) == NULL) && ferror(stream))
 804a6a5:	85 c0                	test   %eax,%eax
 804a6a7:	89 c3                	mov    %eax,%ebx
 804a6a9:	74 0d                	je     804a6b8 <Fgets+0x38>
	app_error("Fgets error");

    return rptr;
}
 804a6ab:	89 d8                	mov    %ebx,%eax
 804a6ad:	8b 75 fc             	mov    -0x4(%ebp),%esi
 804a6b0:	8b 5d f8             	mov    -0x8(%ebp),%ebx
 804a6b3:	89 ec                	mov    %ebp,%esp
 804a6b5:	5d                   	pop    %ebp
 804a6b6:	c3                   	ret    
 804a6b7:	90                   	nop

char *Fgets(char *ptr, int n, FILE *stream) 
{
    char *rptr;

    if (((rptr = fgets(ptr, n, stream)) == NULL) && ferror(stream))
 804a6b8:	89 34 24             	mov    %esi,(%esp)
 804a6bb:	e8 40 e9 ff ff       	call   8049000 <ferror@plt>
 804a6c0:	85 c0                	test   %eax,%eax
 804a6c2:	74 e7                	je     804a6ab <Fgets+0x2b>
	app_error("Fgets error");
 804a6c4:	c7 04 24 0c bc 04 08 	movl   $0x804bc0c,(%esp)
 804a6cb:	e8 70 ff ff ff       	call   804a640 <app_error>
 804a6d0:	eb d9                	jmp    804a6ab <Fgets+0x2b>
 804a6d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804a6d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a6e0 <dns_error>:
    fprintf(stderr, "%s: %s\n", msg, strerror(code));
    exit(0);
}

void dns_error(char *msg) /* dns-style error */
{
 804a6e0:	55                   	push   %ebp
 804a6e1:	89 e5                	mov    %esp,%ebp
 804a6e3:	83 ec 28             	sub    $0x28,%esp
    fprintf(stderr, "%s: DNS error %d\n", msg, h_errno);
 804a6e6:	e8 d5 ea ff ff       	call   80491c0 <__h_errno_location@plt>

# ifdef __va_arg_pack
__extern_always_inline int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 804a6eb:	8b 00                	mov    (%eax),%eax
 804a6ed:	c7 44 24 08 18 bc 04 	movl   $0x804bc18,0x8(%esp)
 804a6f4:	08 
 804a6f5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a6fc:	00 
 804a6fd:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a701:	8b 45 08             	mov    0x8(%ebp),%eax
 804a704:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a708:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a70d:	89 04 24             	mov    %eax,(%esp)
 804a710:	e8 cb ec ff ff       	call   80493e0 <__fprintf_chk@plt>
    exit(0);
 804a715:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a71c:	e8 af ea ff ff       	call   80491d0 <exit@plt>
 804a721:	eb 0d                	jmp    804a730 <Gethostbyaddr>
 804a723:	90                   	nop
 804a724:	90                   	nop
 804a725:	90                   	nop
 804a726:	90                   	nop
 804a727:	90                   	nop
 804a728:	90                   	nop
 804a729:	90                   	nop
 804a72a:	90                   	nop
 804a72b:	90                   	nop
 804a72c:	90                   	nop
 804a72d:	90                   	nop
 804a72e:	90                   	nop
 804a72f:	90                   	nop

0804a730 <Gethostbyaddr>:
    return p;
}
/* $end gethostbyname */

struct hostent *Gethostbyaddr(const char *addr, int len, int type) 
{
 804a730:	55                   	push   %ebp
 804a731:	89 e5                	mov    %esp,%ebp
 804a733:	83 ec 28             	sub    $0x28,%esp
    struct hostent *p;

    if ((p = gethostbyaddr(addr, len, type)) == NULL)
 804a736:	8b 45 10             	mov    0x10(%ebp),%eax
 804a739:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a73d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a740:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a744:	8b 45 08             	mov    0x8(%ebp),%eax
 804a747:	89 04 24             	mov    %eax,(%esp)
 804a74a:	e8 31 e9 ff ff       	call   8049080 <gethostbyaddr@plt>
 804a74f:	85 c0                	test   %eax,%eax
 804a751:	74 05                	je     804a758 <Gethostbyaddr+0x28>
	dns_error("Gethostbyaddr error");
    return p;
}
 804a753:	c9                   	leave  
 804a754:	c3                   	ret    
 804a755:	8d 76 00             	lea    0x0(%esi),%esi
struct hostent *Gethostbyaddr(const char *addr, int len, int type) 
{
    struct hostent *p;

    if ((p = gethostbyaddr(addr, len, type)) == NULL)
	dns_error("Gethostbyaddr error");
 804a758:	c7 04 24 2a bc 04 08 	movl   $0x804bc2a,(%esp)
 804a75f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a762:	e8 79 ff ff ff       	call   804a6e0 <dns_error>
 804a767:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return p;
}
 804a76a:	c9                   	leave  
 804a76b:	c3                   	ret    
 804a76c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a770 <Gethostbyname>:
 * DNS interface wrappers 
 ***********************/

/* $begin gethostbyname */
struct hostent *Gethostbyname(const char *name) 
{
 804a770:	55                   	push   %ebp
 804a771:	89 e5                	mov    %esp,%ebp
 804a773:	83 ec 28             	sub    $0x28,%esp
    struct hostent *p;

    if ((p = gethostbyname(name)) == NULL)
 804a776:	8b 45 08             	mov    0x8(%ebp),%eax
 804a779:	89 04 24             	mov    %eax,(%esp)
 804a77c:	e8 9f ec ff ff       	call   8049420 <gethostbyname@plt>
 804a781:	85 c0                	test   %eax,%eax
 804a783:	74 03                	je     804a788 <Gethostbyname+0x18>
	dns_error("Gethostbyname error");
    return p;
}
 804a785:	c9                   	leave  
 804a786:	c3                   	ret    
 804a787:	90                   	nop
struct hostent *Gethostbyname(const char *name) 
{
    struct hostent *p;

    if ((p = gethostbyname(name)) == NULL)
	dns_error("Gethostbyname error");
 804a788:	c7 04 24 3e bc 04 08 	movl   $0x804bc3e,(%esp)
 804a78f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a792:	e8 49 ff ff ff       	call   804a6e0 <dns_error>
 804a797:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return p;
}
 804a79a:	c9                   	leave  
 804a79b:	c3                   	ret    
 804a79c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a7a0 <posix_error>:
    exit(0);
}
/* $end unixerror */

void posix_error(int code, char *msg) /* posix-style error */
{
 804a7a0:	55                   	push   %ebp
 804a7a1:	89 e5                	mov    %esp,%ebp
 804a7a3:	83 ec 28             	sub    $0x28,%esp
    fprintf(stderr, "%s: %s\n", msg, strerror(code));
 804a7a6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a7a9:	89 04 24             	mov    %eax,(%esp)
 804a7ac:	e8 df e9 ff ff       	call   8049190 <strerror@plt>
 804a7b1:	c7 44 24 08 52 bc 04 	movl   $0x804bc52,0x8(%esp)
 804a7b8:	08 
 804a7b9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a7c0:	00 
 804a7c1:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a7c5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a7c8:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a7cc:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a7d1:	89 04 24             	mov    %eax,(%esp)
 804a7d4:	e8 07 ec ff ff       	call   80493e0 <__fprintf_chk@plt>
    exit(0);
 804a7d9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a7e0:	e8 eb e9 ff ff       	call   80491d0 <exit@plt>
 804a7e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804a7e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a7f0 <Pthread_detach>:
    if ((rc = pthread_join(tid, thread_return)) != 0)
	posix_error(rc, "Pthread_join error");
}

/* $begin detach */
void Pthread_detach(pthread_t tid) {
 804a7f0:	55                   	push   %ebp
 804a7f1:	89 e5                	mov    %esp,%ebp
 804a7f3:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = pthread_detach(tid)) != 0)
 804a7f6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a7f9:	89 04 24             	mov    %eax,(%esp)
 804a7fc:	e8 0f ec ff ff       	call   8049410 <pthread_detach@plt>
 804a801:	85 c0                	test   %eax,%eax
 804a803:	75 03                	jne    804a808 <Pthread_detach+0x18>
	posix_error(rc, "Pthread_detach error");
}
 804a805:	c9                   	leave  
 804a806:	c3                   	ret    
 804a807:	90                   	nop
/* $begin detach */
void Pthread_detach(pthread_t tid) {
    int rc;

    if ((rc = pthread_detach(tid)) != 0)
	posix_error(rc, "Pthread_detach error");
 804a808:	c7 44 24 04 5a bc 04 	movl   $0x804bc5a,0x4(%esp)
 804a80f:	08 
 804a810:	89 04 24             	mov    %eax,(%esp)
 804a813:	e8 88 ff ff ff       	call   804a7a0 <posix_error>
}
 804a818:	c9                   	leave  
 804a819:	c3                   	ret    
 804a81a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804a820 <Pthread_join>:

    if ((rc = pthread_cancel(tid)) != 0)
	posix_error(rc, "Pthread_cancel error");
}

void Pthread_join(pthread_t tid, void **thread_return) {
 804a820:	55                   	push   %ebp
 804a821:	89 e5                	mov    %esp,%ebp
 804a823:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = pthread_join(tid, thread_return)) != 0)
 804a826:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a829:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a82d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a830:	89 04 24             	mov    %eax,(%esp)
 804a833:	e8 88 eb ff ff       	call   80493c0 <pthread_join@plt>
 804a838:	85 c0                	test   %eax,%eax
 804a83a:	75 04                	jne    804a840 <Pthread_join+0x20>
	posix_error(rc, "Pthread_join error");
}
 804a83c:	c9                   	leave  
 804a83d:	c3                   	ret    
 804a83e:	66 90                	xchg   %ax,%ax

void Pthread_join(pthread_t tid, void **thread_return) {
    int rc;

    if ((rc = pthread_join(tid, thread_return)) != 0)
	posix_error(rc, "Pthread_join error");
 804a840:	c7 45 0c 6f bc 04 08 	movl   $0x804bc6f,0xc(%ebp)
 804a847:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a84a:	c9                   	leave  

void Pthread_join(pthread_t tid, void **thread_return) {
    int rc;

    if ((rc = pthread_join(tid, thread_return)) != 0)
	posix_error(rc, "Pthread_join error");
 804a84b:	e9 50 ff ff ff       	jmp    804a7a0 <posix_error>

0804a850 <Pthread_cancel>:

    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
	posix_error(rc, "Pthread_create error");
}

void Pthread_cancel(pthread_t tid) {
 804a850:	55                   	push   %ebp
 804a851:	89 e5                	mov    %esp,%ebp
 804a853:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = pthread_cancel(tid)) != 0)
 804a856:	8b 45 08             	mov    0x8(%ebp),%eax
 804a859:	89 04 24             	mov    %eax,(%esp)
 804a85c:	e8 cf ea ff ff       	call   8049330 <pthread_cancel@plt>
 804a861:	85 c0                	test   %eax,%eax
 804a863:	75 03                	jne    804a868 <Pthread_cancel+0x18>
	posix_error(rc, "Pthread_cancel error");
}
 804a865:	c9                   	leave  
 804a866:	c3                   	ret    
 804a867:	90                   	nop

void Pthread_cancel(pthread_t tid) {
    int rc;

    if ((rc = pthread_cancel(tid)) != 0)
	posix_error(rc, "Pthread_cancel error");
 804a868:	c7 44 24 04 82 bc 04 	movl   $0x804bc82,0x4(%esp)
 804a86f:	08 
 804a870:	89 04 24             	mov    %eax,(%esp)
 804a873:	e8 28 ff ff ff       	call   804a7a0 <posix_error>
}
 804a878:	c9                   	leave  
 804a879:	c3                   	ret    
 804a87a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804a880 <Pthread_create>:
 * Wrappers for Pthreads thread control functions
 ************************************************/

void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, 
		    void * (*routine)(void *), void *argp) 
{
 804a880:	55                   	push   %ebp
 804a881:	89 e5                	mov    %esp,%ebp
 804a883:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
 804a886:	8b 45 14             	mov    0x14(%ebp),%eax
 804a889:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a88d:	8b 45 10             	mov    0x10(%ebp),%eax
 804a890:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a894:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a897:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a89b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a89e:	89 04 24             	mov    %eax,(%esp)
 804a8a1:	e8 4a eb ff ff       	call   80493f0 <pthread_create@plt>
 804a8a6:	85 c0                	test   %eax,%eax
 804a8a8:	75 06                	jne    804a8b0 <Pthread_create+0x30>
	posix_error(rc, "Pthread_create error");
}
 804a8aa:	c9                   	leave  
 804a8ab:	c3                   	ret    
 804a8ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		    void * (*routine)(void *), void *argp) 
{
    int rc;

    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
	posix_error(rc, "Pthread_create error");
 804a8b0:	c7 45 0c 97 bc 04 08 	movl   $0x804bc97,0xc(%ebp)
 804a8b7:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a8ba:	c9                   	leave  
		    void * (*routine)(void *), void *argp) 
{
    int rc;

    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
	posix_error(rc, "Pthread_create error");
 804a8bb:	e9 e0 fe ff ff       	jmp    804a7a0 <posix_error>

0804a8c0 <unix_error>:
 * Error-handling functions
 **************************/
/* $begin errorfuns */
/* $begin unixerror */
void unix_error(char *msg) /* unix-style error */
{
 804a8c0:	55                   	push   %ebp
 804a8c1:	89 e5                	mov    %esp,%ebp
 804a8c3:	83 ec 28             	sub    $0x28,%esp
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
 804a8c6:	e8 55 ea ff ff       	call   8049320 <__errno_location@plt>
 804a8cb:	8b 00                	mov    (%eax),%eax
 804a8cd:	89 04 24             	mov    %eax,(%esp)
 804a8d0:	e8 bb e8 ff ff       	call   8049190 <strerror@plt>
 804a8d5:	c7 44 24 08 52 bc 04 	movl   $0x804bc52,0x8(%esp)
 804a8dc:	08 
 804a8dd:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804a8e4:	00 
 804a8e5:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a8e9:	8b 45 08             	mov    0x8(%ebp),%eax
 804a8ec:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a8f0:	a1 80 e1 04 08       	mov    0x804e180,%eax
 804a8f5:	89 04 24             	mov    %eax,(%esp)
 804a8f8:	e8 e3 ea ff ff       	call   80493e0 <__fprintf_chk@plt>
    exit(0);
 804a8fd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a904:	e8 c7 e8 ff ff       	call   80491d0 <exit@plt>
 804a909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804a910 <Rio_readlineb>:
	unix_error("Rio_readnb error");
    return rc;
}

ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
 804a910:	55                   	push   %ebp
 804a911:	89 e5                	mov    %esp,%ebp
 804a913:	83 ec 28             	sub    $0x28,%esp
    ssize_t rc;

    if ((rc = rio_readlineb(rp, usrbuf, maxlen)) < 0)
 804a916:	8b 45 10             	mov    0x10(%ebp),%eax
 804a919:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a91d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a920:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a924:	8b 45 08             	mov    0x8(%ebp),%eax
 804a927:	89 04 24             	mov    %eax,(%esp)
 804a92a:	e8 31 fb ff ff       	call   804a460 <rio_readlineb>
 804a92f:	85 c0                	test   %eax,%eax
 804a931:	78 05                	js     804a938 <Rio_readlineb+0x28>
	unix_error("Rio_readlineb error");
    return rc;
} 
 804a933:	c9                   	leave  
 804a934:	c3                   	ret    
 804a935:	8d 76 00             	lea    0x0(%esi),%esi
ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
    ssize_t rc;

    if ((rc = rio_readlineb(rp, usrbuf, maxlen)) < 0)
	unix_error("Rio_readlineb error");
 804a938:	c7 04 24 ac bc 04 08 	movl   $0x804bcac,(%esp)
 804a93f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a942:	e8 79 ff ff ff       	call   804a8c0 <unix_error>
 804a947:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
} 
 804a94a:	c9                   	leave  
 804a94b:	c3                   	ret    
 804a94c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a950 <Rio_readnb>:
{
    rio_readinitb(rp, fd);
} 

ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
 804a950:	55                   	push   %ebp
 804a951:	89 e5                	mov    %esp,%ebp
 804a953:	83 ec 28             	sub    $0x28,%esp
    ssize_t rc;

    if ((rc = rio_readnb(rp, usrbuf, n)) < 0)
 804a956:	8b 45 10             	mov    0x10(%ebp),%eax
 804a959:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a95d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a960:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a964:	8b 45 08             	mov    0x8(%ebp),%eax
 804a967:	89 04 24             	mov    %eax,(%esp)
 804a96a:	e8 71 fb ff ff       	call   804a4e0 <rio_readnb>
 804a96f:	85 c0                	test   %eax,%eax
 804a971:	78 05                	js     804a978 <Rio_readnb+0x28>
	unix_error("Rio_readnb error");
    return rc;
}
 804a973:	c9                   	leave  
 804a974:	c3                   	ret    
 804a975:	8d 76 00             	lea    0x0(%esi),%esi
ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
    ssize_t rc;

    if ((rc = rio_readnb(rp, usrbuf, n)) < 0)
	unix_error("Rio_readnb error");
 804a978:	c7 04 24 c0 bc 04 08 	movl   $0x804bcc0,(%esp)
 804a97f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a982:	e8 39 ff ff ff       	call   804a8c0 <unix_error>
 804a987:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804a98a:	c9                   	leave  
 804a98b:	c3                   	ret    
 804a98c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a990 <Rio_writen>:
	unix_error("Rio_readn error");
    return n;
}

void Rio_writen(int fd, void *usrbuf, size_t n) 
{
 804a990:	55                   	push   %ebp
 804a991:	89 e5                	mov    %esp,%ebp
 804a993:	53                   	push   %ebx
 804a994:	83 ec 14             	sub    $0x14,%esp
 804a997:	8b 5d 10             	mov    0x10(%ebp),%ebx
    if (rio_writen(fd, usrbuf, n) != n)
 804a99a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 804a99e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a9a1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a9a5:	8b 45 08             	mov    0x8(%ebp),%eax
 804a9a8:	89 04 24             	mov    %eax,(%esp)
 804a9ab:	e8 a0 fb ff ff       	call   804a550 <rio_writen>
 804a9b0:	39 d8                	cmp    %ebx,%eax
 804a9b2:	74 14                	je     804a9c8 <Rio_writen+0x38>
	unix_error("Rio_writen error");
 804a9b4:	c7 45 08 d1 bc 04 08 	movl   $0x804bcd1,0x8(%ebp)
}
 804a9bb:	83 c4 14             	add    $0x14,%esp
 804a9be:	5b                   	pop    %ebx
 804a9bf:	5d                   	pop    %ebp
}

void Rio_writen(int fd, void *usrbuf, size_t n) 
{
    if (rio_writen(fd, usrbuf, n) != n)
	unix_error("Rio_writen error");
 804a9c0:	e9 fb fe ff ff       	jmp    804a8c0 <unix_error>
 804a9c5:	8d 76 00             	lea    0x0(%esi),%esi
}
 804a9c8:	83 c4 14             	add    $0x14,%esp
 804a9cb:	5b                   	pop    %ebx
 804a9cc:	5d                   	pop    %ebp
 804a9cd:	c3                   	ret    
 804a9ce:	66 90                	xchg   %ax,%ax

0804a9d0 <Rio_readn>:

/**********************************
 * Wrappers for robust I/O routines
 **********************************/
ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) 
{
 804a9d0:	55                   	push   %ebp
 804a9d1:	89 e5                	mov    %esp,%ebp
 804a9d3:	83 ec 28             	sub    $0x28,%esp
    ssize_t n;
  
    if ((n = rio_readn(fd, ptr, nbytes)) < 0)
 804a9d6:	8b 45 10             	mov    0x10(%ebp),%eax
 804a9d9:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a9dd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a9e0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a9e4:	8b 45 08             	mov    0x8(%ebp),%eax
 804a9e7:	89 04 24             	mov    %eax,(%esp)
 804a9ea:	e8 61 f9 ff ff       	call   804a350 <rio_readn>
 804a9ef:	85 c0                	test   %eax,%eax
 804a9f1:	78 05                	js     804a9f8 <Rio_readn+0x28>
	unix_error("Rio_readn error");
    return n;
}
 804a9f3:	c9                   	leave  
 804a9f4:	c3                   	ret    
 804a9f5:	8d 76 00             	lea    0x0(%esi),%esi
ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) 
{
    ssize_t n;
  
    if ((n = rio_readn(fd, ptr, nbytes)) < 0)
	unix_error("Rio_readn error");
 804a9f8:	c7 04 24 e2 bc 04 08 	movl   $0x804bce2,(%esp)
 804a9ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804aa02:	e8 b9 fe ff ff       	call   804a8c0 <unix_error>
 804aa07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return n;
}
 804aa0a:	c9                   	leave  
 804aa0b:	c3                   	ret    
 804aa0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804aa10 <V>:
    if (sem_wait(sem) < 0)
	unix_error("P error");
}

void V(sem_t *sem) 
{
 804aa10:	55                   	push   %ebp
 804aa11:	89 e5                	mov    %esp,%ebp
 804aa13:	83 ec 18             	sub    $0x18,%esp
    if (sem_post(sem) < 0)
 804aa16:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa19:	89 04 24             	mov    %eax,(%esp)
 804aa1c:	e8 9f e8 ff ff       	call   80492c0 <sem_post@plt>
 804aa21:	85 c0                	test   %eax,%eax
 804aa23:	78 03                	js     804aa28 <V+0x18>
	unix_error("V error");
}
 804aa25:	c9                   	leave  
 804aa26:	c3                   	ret    
 804aa27:	90                   	nop
}

void V(sem_t *sem) 
{
    if (sem_post(sem) < 0)
	unix_error("V error");
 804aa28:	c7 45 08 f2 bc 04 08 	movl   $0x804bcf2,0x8(%ebp)
}
 804aa2f:	c9                   	leave  
}

void V(sem_t *sem) 
{
    if (sem_post(sem) < 0)
	unix_error("V error");
 804aa30:	e9 8b fe ff ff       	jmp    804a8c0 <unix_error>
 804aa35:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804aa39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804aa40 <P>:
    if (sem_init(sem, pshared, value) < 0)
	unix_error("Sem_init error");
}

void P(sem_t *sem) 
{
 804aa40:	55                   	push   %ebp
 804aa41:	89 e5                	mov    %esp,%ebp
 804aa43:	83 ec 18             	sub    $0x18,%esp
    if (sem_wait(sem) < 0)
 804aa46:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa49:	89 04 24             	mov    %eax,(%esp)
 804aa4c:	e8 0f e8 ff ff       	call   8049260 <sem_wait@plt>
 804aa51:	85 c0                	test   %eax,%eax
 804aa53:	78 03                	js     804aa58 <P+0x18>
	unix_error("P error");
}
 804aa55:	c9                   	leave  
 804aa56:	c3                   	ret    
 804aa57:	90                   	nop
}

void P(sem_t *sem) 
{
    if (sem_wait(sem) < 0)
	unix_error("P error");
 804aa58:	c7 45 08 fa bc 04 08 	movl   $0x804bcfa,0x8(%ebp)
}
 804aa5f:	c9                   	leave  
}

void P(sem_t *sem) 
{
    if (sem_wait(sem) < 0)
	unix_error("P error");
 804aa60:	e9 5b fe ff ff       	jmp    804a8c0 <unix_error>
 804aa65:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804aa69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804aa70 <Sem_init>:
/*******************************
 * Wrappers for Posix semaphores
 *******************************/

void Sem_init(sem_t *sem, int pshared, unsigned int value) 
{
 804aa70:	55                   	push   %ebp
 804aa71:	89 e5                	mov    %esp,%ebp
 804aa73:	83 ec 18             	sub    $0x18,%esp
    if (sem_init(sem, pshared, value) < 0)
 804aa76:	8b 45 10             	mov    0x10(%ebp),%eax
 804aa79:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aa7d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aa80:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aa84:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa87:	89 04 24             	mov    %eax,(%esp)
 804aa8a:	e8 21 e5 ff ff       	call   8048fb0 <sem_init@plt>
 804aa8f:	85 c0                	test   %eax,%eax
 804aa91:	78 05                	js     804aa98 <Sem_init+0x28>
	unix_error("Sem_init error");
}
 804aa93:	c9                   	leave  
 804aa94:	c3                   	ret    
 804aa95:	8d 76 00             	lea    0x0(%esi),%esi
 *******************************/

void Sem_init(sem_t *sem, int pshared, unsigned int value) 
{
    if (sem_init(sem, pshared, value) < 0)
	unix_error("Sem_init error");
 804aa98:	c7 45 08 02 bd 04 08 	movl   $0x804bd02,0x8(%ebp)
}
 804aa9f:	c9                   	leave  
 *******************************/

void Sem_init(sem_t *sem, int pshared, unsigned int value) 
{
    if (sem_init(sem, pshared, value) < 0)
	unix_error("Sem_init error");
 804aaa0:	e9 1b fe ff ff       	jmp    804a8c0 <unix_error>
 804aaa5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804aaa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804aab0 <Connect>:
	unix_error("Accept error");
    return rc;
}

void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) 
{
 804aab0:	55                   	push   %ebp
 804aab1:	89 e5                	mov    %esp,%ebp
 804aab3:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = connect(sockfd, serv_addr, addrlen)) < 0)
 804aab6:	8b 45 10             	mov    0x10(%ebp),%eax
 804aab9:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aabd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aac0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aac4:	8b 45 08             	mov    0x8(%ebp),%eax
 804aac7:	89 04 24             	mov    %eax,(%esp)
 804aaca:	e8 81 e9 ff ff       	call   8049450 <connect@plt>
 804aacf:	85 c0                	test   %eax,%eax
 804aad1:	78 05                	js     804aad8 <Connect+0x28>
	unix_error("Connect error");
}
 804aad3:	c9                   	leave  
 804aad4:	c3                   	ret    
 804aad5:	8d 76 00             	lea    0x0(%esi),%esi
void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) 
{
    int rc;

    if ((rc = connect(sockfd, serv_addr, addrlen)) < 0)
	unix_error("Connect error");
 804aad8:	c7 45 08 11 bd 04 08 	movl   $0x804bd11,0x8(%ebp)
}
 804aadf:	c9                   	leave  
void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) 
{
    int rc;

    if ((rc = connect(sockfd, serv_addr, addrlen)) < 0)
	unix_error("Connect error");
 804aae0:	e9 db fd ff ff       	jmp    804a8c0 <unix_error>
 804aae5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804aae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804aaf0 <Accept>:
    if ((rc = listen(s,  backlog)) < 0)
	unix_error("Listen error");
}

int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) 
{
 804aaf0:	55                   	push   %ebp
 804aaf1:	89 e5                	mov    %esp,%ebp
 804aaf3:	83 ec 28             	sub    $0x28,%esp
    int rc;

    if ((rc = accept(s, addr, addrlen)) < 0)
 804aaf6:	8b 45 10             	mov    0x10(%ebp),%eax
 804aaf9:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aafd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab00:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ab04:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab07:	89 04 24             	mov    %eax,(%esp)
 804ab0a:	e8 01 e6 ff ff       	call   8049110 <accept@plt>
 804ab0f:	85 c0                	test   %eax,%eax
 804ab11:	78 05                	js     804ab18 <Accept+0x28>
	unix_error("Accept error");
    return rc;
}
 804ab13:	c9                   	leave  
 804ab14:	c3                   	ret    
 804ab15:	8d 76 00             	lea    0x0(%esi),%esi
int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) 
{
    int rc;

    if ((rc = accept(s, addr, addrlen)) < 0)
	unix_error("Accept error");
 804ab18:	c7 04 24 1f bd 04 08 	movl   $0x804bd1f,(%esp)
 804ab1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ab22:	e8 99 fd ff ff       	call   804a8c0 <unix_error>
 804ab27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804ab2a:	c9                   	leave  
 804ab2b:	c3                   	ret    
 804ab2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804ab30 <Listen>:
    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
	unix_error("Bind error");
}

void Listen(int s, int backlog) 
{
 804ab30:	55                   	push   %ebp
 804ab31:	89 e5                	mov    %esp,%ebp
 804ab33:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = listen(s,  backlog)) < 0)
 804ab36:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab39:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ab3d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab40:	89 04 24             	mov    %eax,(%esp)
 804ab43:	e8 58 e8 ff ff       	call   80493a0 <listen@plt>
 804ab48:	85 c0                	test   %eax,%eax
 804ab4a:	78 04                	js     804ab50 <Listen+0x20>
	unix_error("Listen error");
}
 804ab4c:	c9                   	leave  
 804ab4d:	c3                   	ret    
 804ab4e:	66 90                	xchg   %ax,%ax
void Listen(int s, int backlog) 
{
    int rc;

    if ((rc = listen(s,  backlog)) < 0)
	unix_error("Listen error");
 804ab50:	c7 45 08 2c bd 04 08 	movl   $0x804bd2c,0x8(%ebp)
}
 804ab57:	c9                   	leave  
void Listen(int s, int backlog) 
{
    int rc;

    if ((rc = listen(s,  backlog)) < 0)
	unix_error("Listen error");
 804ab58:	e9 63 fd ff ff       	jmp    804a8c0 <unix_error>
 804ab5d:	8d 76 00             	lea    0x0(%esi),%esi

0804ab60 <Bind>:
    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
	unix_error("Setsockopt error");
}

void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) 
{
 804ab60:	55                   	push   %ebp
 804ab61:	89 e5                	mov    %esp,%ebp
 804ab63:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
 804ab66:	8b 45 10             	mov    0x10(%ebp),%eax
 804ab69:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ab6d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab70:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ab74:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab77:	89 04 24             	mov    %eax,(%esp)
 804ab7a:	e8 61 e7 ff ff       	call   80492e0 <bind@plt>
 804ab7f:	85 c0                	test   %eax,%eax
 804ab81:	78 05                	js     804ab88 <Bind+0x28>
	unix_error("Bind error");
}
 804ab83:	c9                   	leave  
 804ab84:	c3                   	ret    
 804ab85:	8d 76 00             	lea    0x0(%esi),%esi
void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) 
{
    int rc;

    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
	unix_error("Bind error");
 804ab88:	c7 45 08 39 bd 04 08 	movl   $0x804bd39,0x8(%ebp)
}
 804ab8f:	c9                   	leave  
void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) 
{
    int rc;

    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
	unix_error("Bind error");
 804ab90:	e9 2b fd ff ff       	jmp    804a8c0 <unix_error>
 804ab95:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804ab99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804aba0 <Setsockopt>:
	unix_error("Socket error");
    return rc;
}

void Setsockopt(int s, int level, int optname, const void *optval, int optlen) 
{
 804aba0:	55                   	push   %ebp
 804aba1:	89 e5                	mov    %esp,%ebp
 804aba3:	83 ec 28             	sub    $0x28,%esp
    int rc;

    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
 804aba6:	8b 45 18             	mov    0x18(%ebp),%eax
 804aba9:	89 44 24 10          	mov    %eax,0x10(%esp)
 804abad:	8b 45 14             	mov    0x14(%ebp),%eax
 804abb0:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804abb4:	8b 45 10             	mov    0x10(%ebp),%eax
 804abb7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804abbb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804abbe:	89 44 24 04          	mov    %eax,0x4(%esp)
 804abc2:	8b 45 08             	mov    0x8(%ebp),%eax
 804abc5:	89 04 24             	mov    %eax,(%esp)
 804abc8:	e8 93 e3 ff ff       	call   8048f60 <setsockopt@plt>
 804abcd:	85 c0                	test   %eax,%eax
 804abcf:	78 07                	js     804abd8 <Setsockopt+0x38>
	unix_error("Setsockopt error");
}
 804abd1:	c9                   	leave  
 804abd2:	c3                   	ret    
 804abd3:	90                   	nop
 804abd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void Setsockopt(int s, int level, int optname, const void *optval, int optlen) 
{
    int rc;

    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
	unix_error("Setsockopt error");
 804abd8:	c7 45 08 44 bd 04 08 	movl   $0x804bd44,0x8(%ebp)
}
 804abdf:	c9                   	leave  
void Setsockopt(int s, int level, int optname, const void *optval, int optlen) 
{
    int rc;

    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
	unix_error("Setsockopt error");
 804abe0:	e9 db fc ff ff       	jmp    804a8c0 <unix_error>
 804abe5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804abe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804abf0 <Socket>:
/**************************** 
 * Sockets interface wrappers
 ****************************/

int Socket(int domain, int type, int protocol) 
{
 804abf0:	55                   	push   %ebp
 804abf1:	89 e5                	mov    %esp,%ebp
 804abf3:	83 ec 28             	sub    $0x28,%esp
    int rc;

    if ((rc = socket(domain, type, protocol)) < 0)
 804abf6:	8b 45 10             	mov    0x10(%ebp),%eax
 804abf9:	89 44 24 08          	mov    %eax,0x8(%esp)
 804abfd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ac00:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ac04:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac07:	89 04 24             	mov    %eax,(%esp)
 804ac0a:	e8 c1 e7 ff ff       	call   80493d0 <socket@plt>
 804ac0f:	85 c0                	test   %eax,%eax
 804ac11:	78 05                	js     804ac18 <Socket+0x28>
	unix_error("Socket error");
    return rc;
}
 804ac13:	c9                   	leave  
 804ac14:	c3                   	ret    
 804ac15:	8d 76 00             	lea    0x0(%esi),%esi
int Socket(int domain, int type, int protocol) 
{
    int rc;

    if ((rc = socket(domain, type, protocol)) < 0)
	unix_error("Socket error");
 804ac18:	c7 04 24 55 bd 04 08 	movl   $0x804bd55,(%esp)
 804ac1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ac22:	e8 99 fc ff ff       	call   804a8c0 <unix_error>
 804ac27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804ac2a:	c9                   	leave  
 804ac2b:	c3                   	ret    
 804ac2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804ac30 <Fwrite>:
	unix_error("Fread error");
    return n;
}

void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
 804ac30:	55                   	push   %ebp
 804ac31:	89 e5                	mov    %esp,%ebp
 804ac33:	53                   	push   %ebx
 804ac34:	83 ec 14             	sub    $0x14,%esp
 804ac37:	8b 5d 10             	mov    0x10(%ebp),%ebx
    if (fwrite(ptr, size, nmemb, stream) < nmemb)
 804ac3a:	8b 45 14             	mov    0x14(%ebp),%eax
 804ac3d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 804ac41:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804ac45:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ac48:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ac4c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac4f:	89 04 24             	mov    %eax,(%esp)
 804ac52:	e8 c9 e4 ff ff       	call   8049120 <fwrite@plt>
 804ac57:	39 c3                	cmp    %eax,%ebx
 804ac59:	77 0d                	ja     804ac68 <Fwrite+0x38>
	unix_error("Fwrite error");
}
 804ac5b:	83 c4 14             	add    $0x14,%esp
 804ac5e:	5b                   	pop    %ebx
 804ac5f:	5d                   	pop    %ebp
 804ac60:	c3                   	ret    
 804ac61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    if (fwrite(ptr, size, nmemb, stream) < nmemb)
	unix_error("Fwrite error");
 804ac68:	c7 45 08 62 bd 04 08 	movl   $0x804bd62,0x8(%ebp)
}
 804ac6f:	83 c4 14             	add    $0x14,%esp
 804ac72:	5b                   	pop    %ebx
 804ac73:	5d                   	pop    %ebp
}

void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    if (fwrite(ptr, size, nmemb, stream) < nmemb)
	unix_error("Fwrite error");
 804ac74:	e9 47 fc ff ff       	jmp    804a8c0 <unix_error>
 804ac79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804ac80 <Fread>:
    if (fputs(ptr, stream) == EOF)
	unix_error("Fputs error");
}

size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
 804ac80:	55                   	push   %ebp
 804ac81:	89 e5                	mov    %esp,%ebp
 804ac83:	83 ec 28             	sub    $0x28,%esp
	return __fread_chk (__ptr, __bos0 (__ptr), __size, __n, __stream);

      if (__size * __n > __bos0 (__ptr))
	return __fread_chk_warn (__ptr, __bos0 (__ptr), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
 804ac86:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ac89:	89 75 f8             	mov    %esi,-0x8(%ebp)
 804ac8c:	8b 75 10             	mov    0x10(%ebp),%esi
 804ac8f:	89 7d fc             	mov    %edi,-0x4(%ebp)
 804ac92:	8b 7d 14             	mov    0x14(%ebp),%edi
 804ac95:	89 5d f4             	mov    %ebx,-0xc(%ebp)
 804ac98:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ac9c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac9f:	89 74 24 08          	mov    %esi,0x8(%esp)
 804aca3:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 804aca7:	89 04 24             	mov    %eax,(%esp)
 804acaa:	e8 91 e4 ff ff       	call   8049140 <fread@plt>
    size_t n;

    if (((n = fread(ptr, size, nmemb, stream)) < nmemb) && ferror(stream)) 
 804acaf:	39 c6                	cmp    %eax,%esi
 804acb1:	89 c3                	mov    %eax,%ebx
 804acb3:	77 13                	ja     804acc8 <Fread+0x48>
	unix_error("Fread error");
    return n;
}
 804acb5:	89 d8                	mov    %ebx,%eax
 804acb7:	8b 75 f8             	mov    -0x8(%ebp),%esi
 804acba:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 804acbd:	8b 7d fc             	mov    -0x4(%ebp),%edi
 804acc0:	89 ec                	mov    %ebp,%esp
 804acc2:	5d                   	pop    %ebp
 804acc3:	c3                   	ret    
 804acc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    size_t n;

    if (((n = fread(ptr, size, nmemb, stream)) < nmemb) && ferror(stream)) 
 804acc8:	89 3c 24             	mov    %edi,(%esp)
 804accb:	e8 30 e3 ff ff       	call   8049000 <ferror@plt>
 804acd0:	85 c0                	test   %eax,%eax
 804acd2:	74 e1                	je     804acb5 <Fread+0x35>
	unix_error("Fread error");
 804acd4:	c7 04 24 6f bd 04 08 	movl   $0x804bd6f,(%esp)
 804acdb:	e8 e0 fb ff ff       	call   804a8c0 <unix_error>
 804ace0:	eb d3                	jmp    804acb5 <Fread+0x35>
 804ace2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804ace9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804acf0 <Fputs>:

    return fp;
}

void Fputs(const char *ptr, FILE *stream) 
{
 804acf0:	55                   	push   %ebp
 804acf1:	89 e5                	mov    %esp,%ebp
 804acf3:	83 ec 18             	sub    $0x18,%esp
    if (fputs(ptr, stream) == EOF)
 804acf6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804acf9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804acfd:	8b 45 08             	mov    0x8(%ebp),%eax
 804ad00:	89 04 24             	mov    %eax,(%esp)
 804ad03:	e8 38 e7 ff ff       	call   8049440 <fputs@plt>
 804ad08:	83 f8 ff             	cmp    $0xffffffff,%eax
 804ad0b:	74 03                	je     804ad10 <Fputs+0x20>
	unix_error("Fputs error");
}
 804ad0d:	c9                   	leave  
 804ad0e:	c3                   	ret    
 804ad0f:	90                   	nop
}

void Fputs(const char *ptr, FILE *stream) 
{
    if (fputs(ptr, stream) == EOF)
	unix_error("Fputs error");
 804ad10:	c7 45 08 7b bd 04 08 	movl   $0x804bd7b,0x8(%ebp)
}
 804ad17:	c9                   	leave  
}

void Fputs(const char *ptr, FILE *stream) 
{
    if (fputs(ptr, stream) == EOF)
	unix_error("Fputs error");
 804ad18:	e9 a3 fb ff ff       	jmp    804a8c0 <unix_error>
 804ad1d:	8d 76 00             	lea    0x0(%esi),%esi

0804ad20 <Fopen>:

    return rptr;
}

FILE *Fopen(const char *filename, const char *mode) 
{
 804ad20:	55                   	push   %ebp
 804ad21:	89 e5                	mov    %esp,%ebp
 804ad23:	83 ec 28             	sub    $0x28,%esp
    FILE *fp;

    if ((fp = fopen(filename, mode)) == NULL)
 804ad26:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ad29:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ad2d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ad30:	89 04 24             	mov    %eax,(%esp)
 804ad33:	e8 d8 e5 ff ff       	call   8049310 <fopen@plt>
 804ad38:	85 c0                	test   %eax,%eax
 804ad3a:	74 04                	je     804ad40 <Fopen+0x20>
	unix_error("Fopen error");

    return fp;
}
 804ad3c:	c9                   	leave  
 804ad3d:	c3                   	ret    
 804ad3e:	66 90                	xchg   %ax,%ax
FILE *Fopen(const char *filename, const char *mode) 
{
    FILE *fp;

    if ((fp = fopen(filename, mode)) == NULL)
	unix_error("Fopen error");
 804ad40:	c7 04 24 87 bd 04 08 	movl   $0x804bd87,(%esp)
 804ad47:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ad4a:	e8 71 fb ff ff       	call   804a8c0 <unix_error>
 804ad4f:	8b 45 f4             	mov    -0xc(%ebp),%eax

    return fp;
}
 804ad52:	c9                   	leave  
 804ad53:	c3                   	ret    
 804ad54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ad5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ad60 <Fdopen>:
    if (fclose(fp) != 0)
	unix_error("Fclose error");
}

FILE *Fdopen(int fd, const char *type) 
{
 804ad60:	55                   	push   %ebp
 804ad61:	89 e5                	mov    %esp,%ebp
 804ad63:	83 ec 28             	sub    $0x28,%esp
    FILE *fp;

    if ((fp = fdopen(fd, type)) == NULL)
 804ad66:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ad69:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ad6d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ad70:	89 04 24             	mov    %eax,(%esp)
 804ad73:	e8 98 e4 ff ff       	call   8049210 <fdopen@plt>
 804ad78:	85 c0                	test   %eax,%eax
 804ad7a:	74 04                	je     804ad80 <Fdopen+0x20>
	unix_error("Fdopen error");

    return fp;
}
 804ad7c:	c9                   	leave  
 804ad7d:	c3                   	ret    
 804ad7e:	66 90                	xchg   %ax,%ax
FILE *Fdopen(int fd, const char *type) 
{
    FILE *fp;

    if ((fp = fdopen(fd, type)) == NULL)
	unix_error("Fdopen error");
 804ad80:	c7 04 24 93 bd 04 08 	movl   $0x804bd93,(%esp)
 804ad87:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ad8a:	e8 31 fb ff ff       	call   804a8c0 <unix_error>
 804ad8f:	8b 45 f4             	mov    -0xc(%ebp),%eax

    return fp;
}
 804ad92:	c9                   	leave  
 804ad93:	c3                   	ret    
 804ad94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ad9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ada0 <Fclose>:

/******************************************
 * Wrappers for the Standard I/O functions.
 ******************************************/
void Fclose(FILE *fp) 
{
 804ada0:	55                   	push   %ebp
 804ada1:	89 e5                	mov    %esp,%ebp
 804ada3:	83 ec 18             	sub    $0x18,%esp
    if (fclose(fp) != 0)
 804ada6:	8b 45 08             	mov    0x8(%ebp),%eax
 804ada9:	89 04 24             	mov    %eax,(%esp)
 804adac:	e8 6f e2 ff ff       	call   8049020 <fclose@plt>
 804adb1:	85 c0                	test   %eax,%eax
 804adb3:	75 03                	jne    804adb8 <Fclose+0x18>
	unix_error("Fclose error");
}
 804adb5:	c9                   	leave  
 804adb6:	c3                   	ret    
 804adb7:	90                   	nop
 * Wrappers for the Standard I/O functions.
 ******************************************/
void Fclose(FILE *fp) 
{
    if (fclose(fp) != 0)
	unix_error("Fclose error");
 804adb8:	c7 45 08 a0 bd 04 08 	movl   $0x804bda0,0x8(%ebp)
}
 804adbf:	c9                   	leave  
 * Wrappers for the Standard I/O functions.
 ******************************************/
void Fclose(FILE *fp) 
{
    if (fclose(fp) != 0)
	unix_error("Fclose error");
 804adc0:	e9 fb fa ff ff       	jmp    804a8c0 <unix_error>
 804adc5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804adc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804add0 <Calloc>:
	unix_error("Realloc error");
    return p;
}

void *Calloc(size_t nmemb, size_t size) 
{
 804add0:	55                   	push   %ebp
 804add1:	89 e5                	mov    %esp,%ebp
 804add3:	83 ec 28             	sub    $0x28,%esp
    void *p;

    if ((p = calloc(nmemb, size)) == NULL)
 804add6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804add9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804addd:	8b 45 08             	mov    0x8(%ebp),%eax
 804ade0:	89 04 24             	mov    %eax,(%esp)
 804ade3:	e8 98 e6 ff ff       	call   8049480 <calloc@plt>
 804ade8:	85 c0                	test   %eax,%eax
 804adea:	74 04                	je     804adf0 <Calloc+0x20>
    {
	unix_error("Calloc error");
    }
    return p;
}
 804adec:	c9                   	leave  
 804aded:	c3                   	ret    
 804adee:	66 90                	xchg   %ax,%ax
{
    void *p;

    if ((p = calloc(nmemb, size)) == NULL)
    {
	unix_error("Calloc error");
 804adf0:	c7 04 24 ad bd 04 08 	movl   $0x804bdad,(%esp)
 804adf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804adfa:	e8 c1 fa ff ff       	call   804a8c0 <unix_error>
 804adff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
    return p;
}
 804ae02:	c9                   	leave  
 804ae03:	c3                   	ret    
 804ae04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ae0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ae10 <Realloc>:
	unix_error("Malloc error");
    return p;
}

void *Realloc(void *ptr, size_t size) 
{
 804ae10:	55                   	push   %ebp
 804ae11:	89 e5                	mov    %esp,%ebp
 804ae13:	83 ec 28             	sub    $0x28,%esp
    void *p;

    if ((p  = realloc(ptr, size)) == NULL)
 804ae16:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ae19:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ae1d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae20:	89 04 24             	mov    %eax,(%esp)
 804ae23:	e8 38 e3 ff ff       	call   8049160 <realloc@plt>
 804ae28:	85 c0                	test   %eax,%eax
 804ae2a:	74 04                	je     804ae30 <Realloc+0x20>
	unix_error("Realloc error");
    return p;
}
 804ae2c:	c9                   	leave  
 804ae2d:	c3                   	ret    
 804ae2e:	66 90                	xchg   %ax,%ax
void *Realloc(void *ptr, size_t size) 
{
    void *p;

    if ((p  = realloc(ptr, size)) == NULL)
	unix_error("Realloc error");
 804ae30:	c7 04 24 ba bd 04 08 	movl   $0x804bdba,(%esp)
 804ae37:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ae3a:	e8 81 fa ff ff       	call   804a8c0 <unix_error>
 804ae3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return p;
}
 804ae42:	c9                   	leave  
 804ae43:	c3                   	ret    
 804ae44:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ae4a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ae50 <Malloc>:
/***************************************************
 * Wrappers for dynamic storage allocation functions
 ***************************************************/

void *Malloc(size_t size) 
{
 804ae50:	55                   	push   %ebp
 804ae51:	89 e5                	mov    %esp,%ebp
 804ae53:	83 ec 28             	sub    $0x28,%esp
    void *p;

    if ((p  = malloc(size)) == NULL)
 804ae56:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae59:	89 04 24             	mov    %eax,(%esp)
 804ae5c:	e8 0f e3 ff ff       	call   8049170 <malloc@plt>
 804ae61:	85 c0                	test   %eax,%eax
 804ae63:	74 03                	je     804ae68 <Malloc+0x18>
	unix_error("Malloc error");
    return p;
}
 804ae65:	c9                   	leave  
 804ae66:	c3                   	ret    
 804ae67:	90                   	nop
void *Malloc(size_t size) 
{
    void *p;

    if ((p  = malloc(size)) == NULL)
	unix_error("Malloc error");
 804ae68:	c7 04 24 c8 bd 04 08 	movl   $0x804bdc8,(%esp)
 804ae6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ae72:	e8 49 fa ff ff       	call   804a8c0 <unix_error>
 804ae77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return p;
}
 804ae7a:	c9                   	leave  
 804ae7b:	c3                   	ret    
 804ae7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804ae80 <Munmap>:
	unix_error("mmap error");
    return(ptr);
}

void Munmap(void *start, size_t length) 
{
 804ae80:	55                   	push   %ebp
 804ae81:	89 e5                	mov    %esp,%ebp
 804ae83:	83 ec 18             	sub    $0x18,%esp
    if (munmap(start, length) < 0)
 804ae86:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ae89:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ae8d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae90:	89 04 24             	mov    %eax,(%esp)
 804ae93:	e8 d8 e4 ff ff       	call   8049370 <munmap@plt>
 804ae98:	85 c0                	test   %eax,%eax
 804ae9a:	78 04                	js     804aea0 <Munmap+0x20>
	unix_error("munmap error");
}
 804ae9c:	c9                   	leave  
 804ae9d:	c3                   	ret    
 804ae9e:	66 90                	xchg   %ax,%ax
}

void Munmap(void *start, size_t length) 
{
    if (munmap(start, length) < 0)
	unix_error("munmap error");
 804aea0:	c7 45 08 d5 bd 04 08 	movl   $0x804bdd5,0x8(%ebp)
}
 804aea7:	c9                   	leave  
}

void Munmap(void *start, size_t length) 
{
    if (munmap(start, length) < 0)
	unix_error("munmap error");
 804aea8:	e9 13 fa ff ff       	jmp    804a8c0 <unix_error>
 804aead:	8d 76 00             	lea    0x0(%esi),%esi

0804aeb0 <Mmap>:

/***************************************
 * Wrappers for memory mapping functions
 ***************************************/
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) 
{
 804aeb0:	55                   	push   %ebp
 804aeb1:	89 e5                	mov    %esp,%ebp
 804aeb3:	83 ec 38             	sub    $0x38,%esp
    void *ptr;

    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))
 804aeb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804aeb9:	89 44 24 14          	mov    %eax,0x14(%esp)
 804aebd:	8b 45 18             	mov    0x18(%ebp),%eax
 804aec0:	89 44 24 10          	mov    %eax,0x10(%esp)
 804aec4:	8b 45 14             	mov    0x14(%ebp),%eax
 804aec7:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804aecb:	8b 45 10             	mov    0x10(%ebp),%eax
 804aece:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aed2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aed5:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aed9:	8b 45 08             	mov    0x8(%ebp),%eax
 804aedc:	89 04 24             	mov    %eax,(%esp)
 804aedf:	e8 4c e3 ff ff       	call   8049230 <mmap@plt>
 804aee4:	83 f8 ff             	cmp    $0xffffffff,%eax
 804aee7:	74 07                	je     804aef0 <Mmap+0x40>
	unix_error("mmap error");
    return(ptr);
}
 804aee9:	c9                   	leave  
 804aeea:	c3                   	ret    
 804aeeb:	90                   	nop
 804aeec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) 
{
    void *ptr;

    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))
	unix_error("mmap error");
 804aef0:	c7 04 24 e2 bd 04 08 	movl   $0x804bde2,(%esp)
 804aef7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804aefa:	e8 c1 f9 ff ff       	call   804a8c0 <unix_error>
 804aeff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return(ptr);
}
 804af02:	c9                   	leave  
 804af03:	c3                   	ret    
 804af04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804af0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804af10 <Fstat>:
    if (stat(filename, buf) < 0)
	unix_error("Stat error");
}

void Fstat(int fd, struct stat *buf) 
{
 804af10:	55                   	push   %ebp
 804af11:	89 e5                	mov    %esp,%ebp
 804af13:	83 ec 18             	sub    $0x18,%esp
# endif

__extern_inline int
__NTH (fstat (int __fd, struct stat *__statbuf))
{
  return __fxstat (_STAT_VER, __fd, __statbuf);
 804af16:	8b 45 0c             	mov    0xc(%ebp),%eax
 804af19:	89 44 24 08          	mov    %eax,0x8(%esp)
 804af1d:	8b 45 08             	mov    0x8(%ebp),%eax
 804af20:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
 804af27:	89 44 24 04          	mov    %eax,0x4(%esp)
 804af2b:	e8 50 e2 ff ff       	call   8049180 <__fxstat@plt>
    if (fstat(fd, buf) < 0)
 804af30:	85 c0                	test   %eax,%eax
 804af32:	78 04                	js     804af38 <Fstat+0x28>
	unix_error("Fstat error");
}
 804af34:	c9                   	leave  
 804af35:	c3                   	ret    
 804af36:	66 90                	xchg   %ax,%ax
}

void Fstat(int fd, struct stat *buf) 
{
    if (fstat(fd, buf) < 0)
	unix_error("Fstat error");
 804af38:	c7 45 08 ed bd 04 08 	movl   $0x804bded,0x8(%ebp)
}
 804af3f:	c9                   	leave  
}

void Fstat(int fd, struct stat *buf) 
{
    if (fstat(fd, buf) < 0)
	unix_error("Fstat error");
 804af40:	e9 7b f9 ff ff       	jmp    804a8c0 <unix_error>
 804af45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804af49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804af50 <Stat>:
	unix_error("Dup2 error");
    return rc;
}

void Stat(const char *filename, struct stat *buf) 
{
 804af50:	55                   	push   %ebp
 804af51:	89 e5                	mov    %esp,%ebp
 804af53:	83 ec 18             	sub    $0x18,%esp
/* Inlined versions of the real stat and mknod functions.  */

__extern_inline int
__NTH (stat (__const char *__path, struct stat *__statbuf))
{
  return __xstat (_STAT_VER, __path, __statbuf);
 804af56:	8b 45 0c             	mov    0xc(%ebp),%eax
 804af59:	89 44 24 08          	mov    %eax,0x8(%esp)
 804af5d:	8b 45 08             	mov    0x8(%ebp),%eax
 804af60:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
 804af67:	89 44 24 04          	mov    %eax,0x4(%esp)
 804af6b:	e8 80 e1 ff ff       	call   80490f0 <__xstat@plt>
    if (stat(filename, buf) < 0)
 804af70:	85 c0                	test   %eax,%eax
 804af72:	78 04                	js     804af78 <Stat+0x28>
	unix_error("Stat error");
}
 804af74:	c9                   	leave  
 804af75:	c3                   	ret    
 804af76:	66 90                	xchg   %ax,%ax
}

void Stat(const char *filename, struct stat *buf) 
{
    if (stat(filename, buf) < 0)
	unix_error("Stat error");
 804af78:	c7 45 08 f9 bd 04 08 	movl   $0x804bdf9,0x8(%ebp)
}
 804af7f:	c9                   	leave  
}

void Stat(const char *filename, struct stat *buf) 
{
    if (stat(filename, buf) < 0)
	unix_error("Stat error");
 804af80:	e9 3b f9 ff ff       	jmp    804a8c0 <unix_error>
 804af85:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804af89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804af90 <Dup2>:
	unix_error("Select error");
    return rc;
}

int Dup2(int fd1, int fd2) 
{
 804af90:	55                   	push   %ebp
 804af91:	89 e5                	mov    %esp,%ebp
 804af93:	83 ec 28             	sub    $0x28,%esp
    int rc;

    if ((rc = dup2(fd1, fd2)) < 0)
 804af96:	8b 45 0c             	mov    0xc(%ebp),%eax
 804af99:	89 44 24 04          	mov    %eax,0x4(%esp)
 804af9d:	8b 45 08             	mov    0x8(%ebp),%eax
 804afa0:	89 04 24             	mov    %eax,(%esp)
 804afa3:	e8 c8 df ff ff       	call   8048f70 <dup2@plt>
 804afa8:	85 c0                	test   %eax,%eax
 804afaa:	78 04                	js     804afb0 <Dup2+0x20>
	unix_error("Dup2 error");
    return rc;
}
 804afac:	c9                   	leave  
 804afad:	c3                   	ret    
 804afae:	66 90                	xchg   %ax,%ax
int Dup2(int fd1, int fd2) 
{
    int rc;

    if ((rc = dup2(fd1, fd2)) < 0)
	unix_error("Dup2 error");
 804afb0:	c7 04 24 04 be 04 08 	movl   $0x804be04,(%esp)
 804afb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804afba:	e8 01 f9 ff ff       	call   804a8c0 <unix_error>
 804afbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804afc2:	c9                   	leave  
 804afc3:	c3                   	ret    
 804afc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804afca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804afd0 <Select>:
	unix_error("Close error");
}

int Select(int  n, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds, struct timeval *timeout) 
{
 804afd0:	55                   	push   %ebp
 804afd1:	89 e5                	mov    %esp,%ebp
 804afd3:	83 ec 38             	sub    $0x38,%esp
    int rc;

    if ((rc = select(n, readfds, writefds, exceptfds, timeout)) < 0)
 804afd6:	8b 45 18             	mov    0x18(%ebp),%eax
 804afd9:	89 44 24 10          	mov    %eax,0x10(%esp)
 804afdd:	8b 45 14             	mov    0x14(%ebp),%eax
 804afe0:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804afe4:	8b 45 10             	mov    0x10(%ebp),%eax
 804afe7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804afeb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804afee:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aff2:	8b 45 08             	mov    0x8(%ebp),%eax
 804aff5:	89 04 24             	mov    %eax,(%esp)
 804aff8:	e8 53 e0 ff ff       	call   8049050 <select@plt>
 804affd:	85 c0                	test   %eax,%eax
 804afff:	78 07                	js     804b008 <Select+0x38>
	unix_error("Select error");
    return rc;
}
 804b001:	c9                   	leave  
 804b002:	c3                   	ret    
 804b003:	90                   	nop
 804b004:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	   fd_set *exceptfds, struct timeval *timeout) 
{
    int rc;

    if ((rc = select(n, readfds, writefds, exceptfds, timeout)) < 0)
	unix_error("Select error");
 804b008:	c7 04 24 0f be 04 08 	movl   $0x804be0f,(%esp)
 804b00f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b012:	e8 a9 f8 ff ff       	call   804a8c0 <unix_error>
 804b017:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b01a:	c9                   	leave  
 804b01b:	c3                   	ret    
 804b01c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b020 <Close>:
	unix_error("Lseek error");
    return rc;
}

void Close(int fd) 
{
 804b020:	55                   	push   %ebp
 804b021:	89 e5                	mov    %esp,%ebp
 804b023:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = close(fd)) < 0)
 804b026:	8b 45 08             	mov    0x8(%ebp),%eax
 804b029:	89 04 24             	mov    %eax,(%esp)
 804b02c:	e8 2f e4 ff ff       	call   8049460 <close@plt>
 804b031:	85 c0                	test   %eax,%eax
 804b033:	78 03                	js     804b038 <Close+0x18>
	unix_error("Close error");
}
 804b035:	c9                   	leave  
 804b036:	c3                   	ret    
 804b037:	90                   	nop
void Close(int fd) 
{
    int rc;

    if ((rc = close(fd)) < 0)
	unix_error("Close error");
 804b038:	c7 45 08 1c be 04 08 	movl   $0x804be1c,0x8(%ebp)
}
 804b03f:	c9                   	leave  
void Close(int fd) 
{
    int rc;

    if ((rc = close(fd)) < 0)
	unix_error("Close error");
 804b040:	e9 7b f8 ff ff       	jmp    804a8c0 <unix_error>
 804b045:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b050 <Lseek>:
	unix_error("Write error");
    return rc;
}

off_t Lseek(int fildes, off_t offset, int whence) 
{
 804b050:	55                   	push   %ebp
 804b051:	89 e5                	mov    %esp,%ebp
 804b053:	83 ec 28             	sub    $0x28,%esp
    off_t rc;

    if ((rc = lseek(fildes, offset, whence)) < 0)
 804b056:	8b 45 10             	mov    0x10(%ebp),%eax
 804b059:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b05d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b060:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b064:	8b 45 08             	mov    0x8(%ebp),%eax
 804b067:	89 04 24             	mov    %eax,(%esp)
 804b06a:	e8 c1 df ff ff       	call   8049030 <lseek@plt>
 804b06f:	85 c0                	test   %eax,%eax
 804b071:	78 05                	js     804b078 <Lseek+0x28>
	unix_error("Lseek error");
    return rc;
}
 804b073:	c9                   	leave  
 804b074:	c3                   	ret    
 804b075:	8d 76 00             	lea    0x0(%esi),%esi
off_t Lseek(int fildes, off_t offset, int whence) 
{
    off_t rc;

    if ((rc = lseek(fildes, offset, whence)) < 0)
	unix_error("Lseek error");
 804b078:	c7 04 24 28 be 04 08 	movl   $0x804be28,(%esp)
 804b07f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b082:	e8 39 f8 ff ff       	call   804a8c0 <unix_error>
 804b087:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b08a:	c9                   	leave  
 804b08b:	c3                   	ret    
 804b08c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b090 <Write>:
	unix_error("Read error");
    return rc;
}

ssize_t Write(int fd, const void *buf, size_t count) 
{
 804b090:	55                   	push   %ebp
 804b091:	89 e5                	mov    %esp,%ebp
 804b093:	83 ec 28             	sub    $0x28,%esp
    ssize_t rc;

    if ((rc = write(fd, buf, count)) < 0)
 804b096:	8b 45 10             	mov    0x10(%ebp),%eax
 804b099:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b09d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b0a0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b0a4:	8b 45 08             	mov    0x8(%ebp),%eax
 804b0a7:	89 04 24             	mov    %eax,(%esp)
 804b0aa:	e8 e1 e1 ff ff       	call   8049290 <write@plt>
 804b0af:	85 c0                	test   %eax,%eax
 804b0b1:	78 05                	js     804b0b8 <Write+0x28>
	unix_error("Write error");
    return rc;
}
 804b0b3:	c9                   	leave  
 804b0b4:	c3                   	ret    
 804b0b5:	8d 76 00             	lea    0x0(%esi),%esi
ssize_t Write(int fd, const void *buf, size_t count) 
{
    ssize_t rc;

    if ((rc = write(fd, buf, count)) < 0)
	unix_error("Write error");
 804b0b8:	c7 04 24 34 be 04 08 	movl   $0x804be34,(%esp)
 804b0bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b0c2:	e8 f9 f7 ff ff       	call   804a8c0 <unix_error>
 804b0c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b0ca:	c9                   	leave  
 804b0cb:	c3                   	ret    
 804b0cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b0d0 <Read>:
	unix_error("Open error");
    return rc;
}

ssize_t Read(int fd, void *buf, size_t count) 
{
 804b0d0:	55                   	push   %ebp
 804b0d1:	89 e5                	mov    %esp,%ebp
 804b0d3:	83 ec 28             	sub    $0x28,%esp
 804b0d6:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0d9:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b0dd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b0e0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b0e4:	8b 45 08             	mov    0x8(%ebp),%eax
 804b0e7:	89 04 24             	mov    %eax,(%esp)
 804b0ea:	e8 a1 de ff ff       	call   8048f90 <read@plt>
    ssize_t rc;

    if ((rc = read(fd, buf, count)) < 0) 
 804b0ef:	85 c0                	test   %eax,%eax
 804b0f1:	78 05                	js     804b0f8 <Read+0x28>
	unix_error("Read error");
    return rc;
}
 804b0f3:	c9                   	leave  
 804b0f4:	c3                   	ret    
 804b0f5:	8d 76 00             	lea    0x0(%esi),%esi
ssize_t Read(int fd, void *buf, size_t count) 
{
    ssize_t rc;

    if ((rc = read(fd, buf, count)) < 0) 
	unix_error("Read error");
 804b0f8:	c7 04 24 40 be 04 08 	movl   $0x804be40,(%esp)
 804b0ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b102:	e8 b9 f7 ff ff       	call   804a8c0 <unix_error>
 804b107:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b10a:	c9                   	leave  
 804b10b:	c3                   	ret    
 804b10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b110 <Open>:
/********************************
 * Wrappers for Unix I/O routines
 ********************************/

int Open(const char *pathname, int flags, mode_t mode) 
{
 804b110:	55                   	push   %ebp
 804b111:	89 e5                	mov    %esp,%ebp
 804b113:	83 ec 28             	sub    $0x28,%esp
    }

  if (__va_arg_pack_len () < 1)
    return __open_2 (__path, __oflag);

  return __open_alias (__path, __oflag, __va_arg_pack ());
 804b116:	8b 45 10             	mov    0x10(%ebp),%eax
 804b119:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b11d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b120:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b124:	8b 45 08             	mov    0x8(%ebp),%eax
 804b127:	89 04 24             	mov    %eax,(%esp)
 804b12a:	e8 d1 e0 ff ff       	call   8049200 <open@plt>
    int rc;

    if ((rc = open(pathname, flags, mode))  < 0)
 804b12f:	85 c0                	test   %eax,%eax
 804b131:	78 05                	js     804b138 <Open+0x28>
	unix_error("Open error");
    return rc;
}
 804b133:	c9                   	leave  
 804b134:	c3                   	ret    
 804b135:	8d 76 00             	lea    0x0(%esi),%esi
int Open(const char *pathname, int flags, mode_t mode) 
{
    int rc;

    if ((rc = open(pathname, flags, mode))  < 0)
	unix_error("Open error");
 804b138:	c7 04 24 4b be 04 08 	movl   $0x804be4b,(%esp)
 804b13f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b142:	e8 79 f7 ff ff       	call   804a8c0 <unix_error>
 804b147:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b14a:	c9                   	leave  
 804b14b:	c3                   	ret    
 804b14c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b150 <Sigismember>:
	unix_error("Sigdelset error");
    return;
}

int Sigismember(const sigset_t *set, int signum)
{
 804b150:	55                   	push   %ebp
 804b151:	89 e5                	mov    %esp,%ebp
 804b153:	83 ec 28             	sub    $0x28,%esp
    int rc;
    if ((rc = sigismember(set, signum)) < 0)
 804b156:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b159:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b15d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b160:	89 04 24             	mov    %eax,(%esp)
 804b163:	e8 78 df ff ff       	call   80490e0 <sigismember@plt>
 804b168:	85 c0                	test   %eax,%eax
 804b16a:	78 04                	js     804b170 <Sigismember+0x20>
	unix_error("Sigismember error");
    return rc;
}
 804b16c:	c9                   	leave  
 804b16d:	c3                   	ret    
 804b16e:	66 90                	xchg   %ax,%ax

int Sigismember(const sigset_t *set, int signum)
{
    int rc;
    if ((rc = sigismember(set, signum)) < 0)
	unix_error("Sigismember error");
 804b170:	c7 04 24 56 be 04 08 	movl   $0x804be56,(%esp)
 804b177:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b17a:	e8 41 f7 ff ff       	call   804a8c0 <unix_error>
 804b17f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b182:	c9                   	leave  
 804b183:	c3                   	ret    
 804b184:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b18a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804b190 <Sigdelset>:
	unix_error("Sigaddset error");
    return;
}

void Sigdelset(sigset_t *set, int signum)
{
 804b190:	55                   	push   %ebp
 804b191:	89 e5                	mov    %esp,%ebp
 804b193:	83 ec 18             	sub    $0x18,%esp
    if (sigdelset(set, signum) < 0)
 804b196:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b199:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b19d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1a0:	89 04 24             	mov    %eax,(%esp)
 804b1a3:	e8 f8 e0 ff ff       	call   80492a0 <sigdelset@plt>
 804b1a8:	85 c0                	test   %eax,%eax
 804b1aa:	78 04                	js     804b1b0 <Sigdelset+0x20>
	unix_error("Sigdelset error");
    return;
}
 804b1ac:	c9                   	leave  
 804b1ad:	c3                   	ret    
 804b1ae:	66 90                	xchg   %ax,%ax
}

void Sigdelset(sigset_t *set, int signum)
{
    if (sigdelset(set, signum) < 0)
	unix_error("Sigdelset error");
 804b1b0:	c7 45 08 68 be 04 08 	movl   $0x804be68,0x8(%ebp)
    return;
}
 804b1b7:	c9                   	leave  
}

void Sigdelset(sigset_t *set, int signum)
{
    if (sigdelset(set, signum) < 0)
	unix_error("Sigdelset error");
 804b1b8:	e9 03 f7 ff ff       	jmp    804a8c0 <unix_error>
 804b1bd:	8d 76 00             	lea    0x0(%esi),%esi

0804b1c0 <Sigaddset>:
	unix_error("Sigfillset error");
    return;
}

void Sigaddset(sigset_t *set, int signum)
{
 804b1c0:	55                   	push   %ebp
 804b1c1:	89 e5                	mov    %esp,%ebp
 804b1c3:	83 ec 18             	sub    $0x18,%esp
    if (sigaddset(set, signum) < 0)
 804b1c6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b1c9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b1cd:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1d0:	89 04 24             	mov    %eax,(%esp)
 804b1d3:	e8 f8 e0 ff ff       	call   80492d0 <sigaddset@plt>
 804b1d8:	85 c0                	test   %eax,%eax
 804b1da:	78 04                	js     804b1e0 <Sigaddset+0x20>
	unix_error("Sigaddset error");
    return;
}
 804b1dc:	c9                   	leave  
 804b1dd:	c3                   	ret    
 804b1de:	66 90                	xchg   %ax,%ax
}

void Sigaddset(sigset_t *set, int signum)
{
    if (sigaddset(set, signum) < 0)
	unix_error("Sigaddset error");
 804b1e0:	c7 45 08 78 be 04 08 	movl   $0x804be78,0x8(%ebp)
    return;
}
 804b1e7:	c9                   	leave  
}

void Sigaddset(sigset_t *set, int signum)
{
    if (sigaddset(set, signum) < 0)
	unix_error("Sigaddset error");
 804b1e8:	e9 d3 f6 ff ff       	jmp    804a8c0 <unix_error>
 804b1ed:	8d 76 00             	lea    0x0(%esi),%esi

0804b1f0 <Sigfillset>:
	unix_error("Sigemptyset error");
    return;
}

void Sigfillset(sigset_t *set)
{ 
 804b1f0:	55                   	push   %ebp
 804b1f1:	89 e5                	mov    %esp,%ebp
 804b1f3:	83 ec 18             	sub    $0x18,%esp
    if (sigfillset(set) < 0)
 804b1f6:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1f9:	89 04 24             	mov    %eax,(%esp)
 804b1fc:	e8 ef e0 ff ff       	call   80492f0 <sigfillset@plt>
 804b201:	85 c0                	test   %eax,%eax
 804b203:	78 03                	js     804b208 <Sigfillset+0x18>
	unix_error("Sigfillset error");
    return;
}
 804b205:	c9                   	leave  
 804b206:	c3                   	ret    
 804b207:	90                   	nop
}

void Sigfillset(sigset_t *set)
{ 
    if (sigfillset(set) < 0)
	unix_error("Sigfillset error");
 804b208:	c7 45 08 88 be 04 08 	movl   $0x804be88,0x8(%ebp)
    return;
}
 804b20f:	c9                   	leave  
}

void Sigfillset(sigset_t *set)
{ 
    if (sigfillset(set) < 0)
	unix_error("Sigfillset error");
 804b210:	e9 ab f6 ff ff       	jmp    804a8c0 <unix_error>
 804b215:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b220 <Sigemptyset>:
	unix_error("Sigprocmask error");
    return;
}

void Sigemptyset(sigset_t *set)
{
 804b220:	55                   	push   %ebp
 804b221:	89 e5                	mov    %esp,%ebp
 804b223:	83 ec 18             	sub    $0x18,%esp
    if (sigemptyset(set) < 0)
 804b226:	8b 45 08             	mov    0x8(%ebp),%eax
 804b229:	89 04 24             	mov    %eax,(%esp)
 804b22c:	e8 5f e1 ff ff       	call   8049390 <sigemptyset@plt>
 804b231:	85 c0                	test   %eax,%eax
 804b233:	78 03                	js     804b238 <Sigemptyset+0x18>
	unix_error("Sigemptyset error");
    return;
}
 804b235:	c9                   	leave  
 804b236:	c3                   	ret    
 804b237:	90                   	nop
}

void Sigemptyset(sigset_t *set)
{
    if (sigemptyset(set) < 0)
	unix_error("Sigemptyset error");
 804b238:	c7 45 08 99 be 04 08 	movl   $0x804be99,0x8(%ebp)
    return;
}
 804b23f:	c9                   	leave  
}

void Sigemptyset(sigset_t *set)
{
    if (sigemptyset(set) < 0)
	unix_error("Sigemptyset error");
 804b240:	e9 7b f6 ff ff       	jmp    804a8c0 <unix_error>
 804b245:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b250 <Sigprocmask>:
    return (old_action.sa_handler);
}
/* $end sigaction */

void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
{
 804b250:	55                   	push   %ebp
 804b251:	89 e5                	mov    %esp,%ebp
 804b253:	83 ec 18             	sub    $0x18,%esp
    if (sigprocmask(how, set, oldset) < 0)
 804b256:	8b 45 10             	mov    0x10(%ebp),%eax
 804b259:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b25d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b260:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b264:	8b 45 08             	mov    0x8(%ebp),%eax
 804b267:	89 04 24             	mov    %eax,(%esp)
 804b26a:	e8 51 dd ff ff       	call   8048fc0 <sigprocmask@plt>
 804b26f:	85 c0                	test   %eax,%eax
 804b271:	78 05                	js     804b278 <Sigprocmask+0x28>
	unix_error("Sigprocmask error");
    return;
}
 804b273:	c9                   	leave  
 804b274:	c3                   	ret    
 804b275:	8d 76 00             	lea    0x0(%esi),%esi
/* $end sigaction */

void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
{
    if (sigprocmask(how, set, oldset) < 0)
	unix_error("Sigprocmask error");
 804b278:	c7 45 08 ab be 04 08 	movl   $0x804beab,0x8(%ebp)
    return;
}
 804b27f:	c9                   	leave  
/* $end sigaction */

void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
{
    if (sigprocmask(how, set, oldset) < 0)
	unix_error("Sigprocmask error");
 804b280:	e9 3b f6 ff ff       	jmp    804a8c0 <unix_error>
 804b285:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b290 <Signal>:
 * Wrappers for Unix signal functions 
 ***********************************/

/* $begin sigaction */
handler_t *Signal(int signum, handler_t *handler) 
{
 804b290:	55                   	push   %ebp
 804b291:	89 e5                	mov    %esp,%ebp
 804b293:	53                   	push   %ebx
 804b294:	81 ec 34 01 00 00    	sub    $0x134,%esp
    struct sigaction action, old_action;

    action.sa_handler = handler;  
 804b29a:	8b 45 0c             	mov    0xc(%ebp),%eax
    sigemptyset(&action.sa_mask); /* block sigs of type being handled */
 804b29d:	8d 9d 6c ff ff ff    	lea    -0x94(%ebp),%ebx
/* $begin sigaction */
handler_t *Signal(int signum, handler_t *handler) 
{
    struct sigaction action, old_action;

    action.sa_handler = handler;  
 804b2a3:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
    sigemptyset(&action.sa_mask); /* block sigs of type being handled */
 804b2a9:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
 804b2af:	89 04 24             	mov    %eax,(%esp)
 804b2b2:	e8 d9 e0 ff ff       	call   8049390 <sigemptyset@plt>
    action.sa_flags = SA_RESTART; /* restart syscalls if possible */

    if (sigaction(signum, &action, &old_action) < 0)
 804b2b7:	8d 85 e0 fe ff ff    	lea    -0x120(%ebp),%eax
{
    struct sigaction action, old_action;

    action.sa_handler = handler;  
    sigemptyset(&action.sa_mask); /* block sigs of type being handled */
    action.sa_flags = SA_RESTART; /* restart syscalls if possible */
 804b2bd:	c7 45 f0 00 00 00 10 	movl   $0x10000000,-0x10(%ebp)

    if (sigaction(signum, &action, &old_action) < 0)
 804b2c4:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b2c8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b2cc:	8b 45 08             	mov    0x8(%ebp),%eax
 804b2cf:	89 04 24             	mov    %eax,(%esp)
 804b2d2:	e8 29 e1 ff ff       	call   8049400 <sigaction@plt>
 804b2d7:	85 c0                	test   %eax,%eax
 804b2d9:	78 15                	js     804b2f0 <Signal+0x60>
	unix_error("Signal error");
    return (old_action.sa_handler);
}
 804b2db:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
 804b2e1:	81 c4 34 01 00 00    	add    $0x134,%esp
 804b2e7:	5b                   	pop    %ebx
 804b2e8:	5d                   	pop    %ebp
 804b2e9:	c3                   	ret    
 804b2ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    action.sa_handler = handler;  
    sigemptyset(&action.sa_mask); /* block sigs of type being handled */
    action.sa_flags = SA_RESTART; /* restart syscalls if possible */

    if (sigaction(signum, &action, &old_action) < 0)
	unix_error("Signal error");
 804b2f0:	c7 04 24 bd be 04 08 	movl   $0x804bebd,(%esp)
 804b2f7:	e8 c4 f5 ff ff       	call   804a8c0 <unix_error>
    return (old_action.sa_handler);
}
 804b2fc:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
 804b302:	81 c4 34 01 00 00    	add    $0x134,%esp
 804b308:	5b                   	pop    %ebx
 804b309:	5d                   	pop    %ebp
 804b30a:	c3                   	ret    
 804b30b:	90                   	nop
 804b30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b310 <Setpgid>:

unsigned int Alarm(unsigned int seconds) {
    return alarm(seconds);
}
 
void Setpgid(pid_t pid, pid_t pgid) {
 804b310:	55                   	push   %ebp
 804b311:	89 e5                	mov    %esp,%ebp
 804b313:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = setpgid(pid, pgid)) < 0)
 804b316:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b319:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b31d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b320:	89 04 24             	mov    %eax,(%esp)
 804b323:	e8 88 e0 ff ff       	call   80493b0 <setpgid@plt>
 804b328:	85 c0                	test   %eax,%eax
 804b32a:	78 04                	js     804b330 <Setpgid+0x20>
	unix_error("Setpgid error");
    return;
}
 804b32c:	c9                   	leave  
 804b32d:	c3                   	ret    
 804b32e:	66 90                	xchg   %ax,%ax
 
void Setpgid(pid_t pid, pid_t pgid) {
    int rc;

    if ((rc = setpgid(pid, pgid)) < 0)
	unix_error("Setpgid error");
 804b330:	c7 45 08 ca be 04 08 	movl   $0x804beca,0x8(%ebp)
    return;
}
 804b337:	c9                   	leave  
 
void Setpgid(pid_t pid, pid_t pgid) {
    int rc;

    if ((rc = setpgid(pid, pgid)) < 0)
	unix_error("Setpgid error");
 804b338:	e9 83 f5 ff ff       	jmp    804a8c0 <unix_error>
 804b33d:	8d 76 00             	lea    0x0(%esi),%esi

0804b340 <Kill>:
    return(retpid);
}

/* $begin kill */
void Kill(pid_t pid, int signum) 
{
 804b340:	55                   	push   %ebp
 804b341:	89 e5                	mov    %esp,%ebp
 804b343:	83 ec 18             	sub    $0x18,%esp
    int rc;

    if ((rc = kill(pid, signum)) < 0)
 804b346:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b349:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b34d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b350:	89 04 24             	mov    %eax,(%esp)
 804b353:	e8 98 de ff ff       	call   80491f0 <kill@plt>
 804b358:	85 c0                	test   %eax,%eax
 804b35a:	78 04                	js     804b360 <Kill+0x20>
	unix_error("Kill error");
}
 804b35c:	c9                   	leave  
 804b35d:	c3                   	ret    
 804b35e:	66 90                	xchg   %ax,%ax
void Kill(pid_t pid, int signum) 
{
    int rc;

    if ((rc = kill(pid, signum)) < 0)
	unix_error("Kill error");
 804b360:	c7 45 08 d8 be 04 08 	movl   $0x804bed8,0x8(%ebp)
}
 804b367:	c9                   	leave  
void Kill(pid_t pid, int signum) 
{
    int rc;

    if ((rc = kill(pid, signum)) < 0)
	unix_error("Kill error");
 804b368:	e9 53 f5 ff ff       	jmp    804a8c0 <unix_error>
 804b36d:	8d 76 00             	lea    0x0(%esi),%esi

0804b370 <Waitpid>:
    return pid;
}
/* $end wait */

pid_t Waitpid(pid_t pid, int *iptr, int options) 
{
 804b370:	55                   	push   %ebp
 804b371:	89 e5                	mov    %esp,%ebp
 804b373:	83 ec 28             	sub    $0x28,%esp
    pid_t retpid;

    if ((retpid  = waitpid(pid, iptr, options)) < 0) 
 804b376:	8b 45 10             	mov    0x10(%ebp),%eax
 804b379:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b37d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b380:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b384:	8b 45 08             	mov    0x8(%ebp),%eax
 804b387:	89 04 24             	mov    %eax,(%esp)
 804b38a:	e8 a1 dd ff ff       	call   8049130 <waitpid@plt>
 804b38f:	85 c0                	test   %eax,%eax
 804b391:	78 05                	js     804b398 <Waitpid+0x28>
	unix_error("Waitpid error");
    return(retpid);
}
 804b393:	c9                   	leave  
 804b394:	c3                   	ret    
 804b395:	8d 76 00             	lea    0x0(%esi),%esi
pid_t Waitpid(pid_t pid, int *iptr, int options) 
{
    pid_t retpid;

    if ((retpid  = waitpid(pid, iptr, options)) < 0) 
	unix_error("Waitpid error");
 804b398:	c7 04 24 e3 be 04 08 	movl   $0x804bee3,(%esp)
 804b39f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b3a2:	e8 19 f5 ff ff       	call   804a8c0 <unix_error>
 804b3a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return(retpid);
}
 804b3aa:	c9                   	leave  
 804b3ab:	c3                   	ret    
 804b3ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b3b0 <Wait>:
	unix_error("Execve error");
}

/* $begin wait */
pid_t Wait(int *status) 
{
 804b3b0:	55                   	push   %ebp
 804b3b1:	89 e5                	mov    %esp,%ebp
 804b3b3:	83 ec 28             	sub    $0x28,%esp
    pid_t pid;

    if ((pid  = wait(status)) < 0)
 804b3b6:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3b9:	89 04 24             	mov    %eax,(%esp)
 804b3bc:	e8 ff dc ff ff       	call   80490c0 <wait@plt>
 804b3c1:	85 c0                	test   %eax,%eax
 804b3c3:	78 03                	js     804b3c8 <Wait+0x18>
	unix_error("Wait error");
    return pid;
}
 804b3c5:	c9                   	leave  
 804b3c6:	c3                   	ret    
 804b3c7:	90                   	nop
pid_t Wait(int *status) 
{
    pid_t pid;

    if ((pid  = wait(status)) < 0)
	unix_error("Wait error");
 804b3c8:	c7 04 24 f1 be 04 08 	movl   $0x804bef1,(%esp)
 804b3cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b3d2:	e8 e9 f4 ff ff       	call   804a8c0 <unix_error>
 804b3d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return pid;
}
 804b3da:	c9                   	leave  
 804b3db:	c3                   	ret    
 804b3dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b3e0 <Execve>:
    return pid;
}
/* $end forkwrapper */

void Execve(const char *filename, char *const argv[], char *const envp[]) 
{
 804b3e0:	55                   	push   %ebp
 804b3e1:	89 e5                	mov    %esp,%ebp
 804b3e3:	83 ec 18             	sub    $0x18,%esp
    if (execve(filename, argv, envp) < 0)
 804b3e6:	8b 45 10             	mov    0x10(%ebp),%eax
 804b3e9:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b3ed:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3f0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b3f4:	8b 45 08             	mov    0x8(%ebp),%eax
 804b3f7:	89 04 24             	mov    %eax,(%esp)
 804b3fa:	e8 81 de ff ff       	call   8049280 <execve@plt>
 804b3ff:	85 c0                	test   %eax,%eax
 804b401:	78 05                	js     804b408 <Execve+0x28>
	unix_error("Execve error");
}
 804b403:	c9                   	leave  
 804b404:	c3                   	ret    
 804b405:	8d 76 00             	lea    0x0(%esi),%esi
/* $end forkwrapper */

void Execve(const char *filename, char *const argv[], char *const envp[]) 
{
    if (execve(filename, argv, envp) < 0)
	unix_error("Execve error");
 804b408:	c7 45 08 fc be 04 08 	movl   $0x804befc,0x8(%ebp)
}
 804b40f:	c9                   	leave  
/* $end forkwrapper */

void Execve(const char *filename, char *const argv[], char *const envp[]) 
{
    if (execve(filename, argv, envp) < 0)
	unix_error("Execve error");
 804b410:	e9 ab f4 ff ff       	jmp    804a8c0 <unix_error>
 804b415:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b420 <Fork>:
 * Wrappers for Unix process control functions
 ********************************************/

/* $begin forkwrapper */
pid_t Fork(void) 
{
 804b420:	55                   	push   %ebp
 804b421:	89 e5                	mov    %esp,%ebp
 804b423:	83 ec 28             	sub    $0x28,%esp
    pid_t pid;

    if ((pid = fork()) < 0)
 804b426:	e8 55 df ff ff       	call   8049380 <fork@plt>
 804b42b:	85 c0                	test   %eax,%eax
 804b42d:	78 09                	js     804b438 <Fork+0x18>
	unix_error("Fork error");
    return pid;
}
 804b42f:	c9                   	leave  
 804b430:	c3                   	ret    
 804b431:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
pid_t Fork(void) 
{
    pid_t pid;

    if ((pid = fork()) < 0)
	unix_error("Fork error");
 804b438:	c7 04 24 09 bf 04 08 	movl   $0x804bf09,(%esp)
 804b43f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b442:	e8 79 f4 ff ff       	call   804a8c0 <unix_error>
 804b447:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return pid;
}
 804b44a:	c9                   	leave  
 804b44b:	c3                   	ret    
 804b44c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b450 <open_listenfd>:
 * open_listenfd - open and return a listening socket on port
 *     Returns -1 and sets errno on Unix error.
 */
/* $begin open_listenfd */
int open_listenfd(int port) 
{
 804b450:	55                   	push   %ebp
 804b451:	89 e5                	mov    %esp,%ebp
 804b453:	53                   	push   %ebx
 804b454:	83 ec 44             	sub    $0x44,%esp
    int listenfd, optval=1;
    struct sockaddr_in serveraddr;
  
    /* Create a socket descriptor */
    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 804b457:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b45e:	00 
 * open_listenfd - open and return a listening socket on port
 *     Returns -1 and sets errno on Unix error.
 */
/* $begin open_listenfd */
int open_listenfd(int port) 
{
 804b45f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b465:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b468:	31 c0                	xor    %eax,%eax
    int listenfd, optval=1;
 804b46a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
    struct sockaddr_in serveraddr;
  
    /* Create a socket descriptor */
    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 804b471:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b478:	00 
 804b479:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804b480:	e8 4b df ff ff       	call   80493d0 <socket@plt>
 804b485:	85 c0                	test   %eax,%eax
 804b487:	89 c3                	mov    %eax,%ebx
 804b489:	79 1d                	jns    804b4a8 <open_listenfd+0x58>
    serveraddr.sin_port = htons((unsigned short)port); 
    if (bind(listenfd, (SA *)&serveraddr, sizeof(serveraddr)) < 0)
	return -1;

    /* Make it a listening socket ready to accept connection requests */
    if (listen(listenfd, LISTENQ) < 0)
 804b48b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
      return -1;
    return listenfd;
}
 804b490:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b493:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
 804b49a:	89 d8                	mov    %ebx,%eax
 804b49c:	0f 85 94 00 00 00    	jne    804b536 <open_listenfd+0xe6>
 804b4a2:	83 c4 44             	add    $0x44,%esp
 804b4a5:	5b                   	pop    %ebx
 804b4a6:	5d                   	pop    %ebp
 804b4a7:	c3                   	ret    
    /* Create a socket descriptor */
    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	return -1;
 
    /* Eliminates "Address already in use" error from bind. */
    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, 
 804b4a8:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804b4ab:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
 804b4b2:	00 
 804b4b3:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804b4b7:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
 804b4be:	00 
 804b4bf:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b4c6:	00 
 804b4c7:	89 1c 24             	mov    %ebx,(%esp)
 804b4ca:	e8 91 da ff ff       	call   8048f60 <setsockopt@plt>
 804b4cf:	85 c0                	test   %eax,%eax
 804b4d1:	78 b8                	js     804b48b <open_listenfd+0x3b>
}

__extern_always_inline void
__NTH (bzero (void *__dest, size_t __len))
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __bos0 (__dest));
 804b4d3:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    /* Listenfd will be an endpoint for all requests to port
       on any IP address for this host */
    bzero((char *) &serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET; 
    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); 
    serveraddr.sin_port = htons((unsigned short)port); 
 804b4d6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
 804b4da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 804b4e1:	66 c1 c8 08          	ror    $0x8,%ax
 804b4e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	return -1;

    /* Listenfd will be an endpoint for all requests to port
       on any IP address for this host */
    bzero((char *) &serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET; 
 804b4ec:	66 c7 45 e4 02 00    	movw   $0x2,-0x1c(%ebp)
    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); 
 804b4f2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    serveraddr.sin_port = htons((unsigned short)port); 
 804b4f9:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    if (bind(listenfd, (SA *)&serveraddr, sizeof(serveraddr)) < 0)
 804b4fd:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
 804b504:	00 
 804b505:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b509:	89 1c 24             	mov    %ebx,(%esp)
 804b50c:	e8 cf dd ff ff       	call   80492e0 <bind@plt>
 804b511:	85 c0                	test   %eax,%eax
 804b513:	0f 88 72 ff ff ff    	js     804b48b <open_listenfd+0x3b>
	return -1;

    /* Make it a listening socket ready to accept connection requests */
    if (listen(listenfd, LISTENQ) < 0)
 804b519:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 804b520:	00 
 804b521:	89 1c 24             	mov    %ebx,(%esp)
 804b524:	e8 77 de ff ff       	call   80493a0 <listen@plt>
 804b529:	85 c0                	test   %eax,%eax
 804b52b:	0f 89 5f ff ff ff    	jns    804b490 <open_listenfd+0x40>
 804b531:	e9 55 ff ff ff       	jmp    804b48b <open_listenfd+0x3b>
 804b536:	66 90                	xchg   %ax,%ax
      return -1;
    return listenfd;
}
 804b538:	e8 53 db ff ff       	call   8049090 <__stack_chk_fail@plt>
 804b53d:	8d 76 00             	lea    0x0(%esi),%esi

0804b540 <Open_listenfd>:
    }
    return rc;
}

int Open_listenfd(int port) 
{
 804b540:	55                   	push   %ebp
 804b541:	89 e5                	mov    %esp,%ebp
 804b543:	83 ec 28             	sub    $0x28,%esp
    int rc;

    if ((rc = open_listenfd(port)) < 0)
 804b546:	8b 45 08             	mov    0x8(%ebp),%eax
 804b549:	89 04 24             	mov    %eax,(%esp)
 804b54c:	e8 ff fe ff ff       	call   804b450 <open_listenfd>
 804b551:	85 c0                	test   %eax,%eax
 804b553:	78 03                	js     804b558 <Open_listenfd+0x18>
	unix_error("Open_listenfd error");
    return rc;
}
 804b555:	c9                   	leave  
 804b556:	c3                   	ret    
 804b557:	90                   	nop
int Open_listenfd(int port) 
{
    int rc;

    if ((rc = open_listenfd(port)) < 0)
	unix_error("Open_listenfd error");
 804b558:	c7 04 24 14 bf 04 08 	movl   $0x804bf14,(%esp)
 804b55f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b562:	e8 59 f3 ff ff       	call   804a8c0 <unix_error>
 804b567:	8b 45 f4             	mov    -0xc(%ebp),%eax
    return rc;
}
 804b56a:	c9                   	leave  
 804b56b:	c3                   	ret    
 804b56c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b570 <open_clientfd>:
 *   Returns -1 and sets errno on Unix error. 
 *   Returns -2 and sets h_errno on DNS (gethostbyname) error.
 */
/* $begin open_clientfd */
int open_clientfd(char *hostname, int port) 
{
 804b570:	55                   	push   %ebp
 804b571:	89 e5                	mov    %esp,%ebp
 804b573:	83 ec 38             	sub    $0x38,%esp
    int clientfd;
    struct hostent *hp;
    struct sockaddr_in serveraddr;

    if ((clientfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 804b576:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b57d:	00 
 *   Returns -1 and sets errno on Unix error. 
 *   Returns -2 and sets h_errno on DNS (gethostbyname) error.
 */
/* $begin open_clientfd */
int open_clientfd(char *hostname, int port) 
{
 804b57e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
 804b581:	89 75 fc             	mov    %esi,-0x4(%ebp)
 804b584:	8b 75 08             	mov    0x8(%ebp),%esi
 804b587:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b58d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b590:	31 c0                	xor    %eax,%eax
    int clientfd;
    struct hostent *hp;
    struct sockaddr_in serveraddr;

    if ((clientfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 804b592:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b599:	00 
 804b59a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804b5a1:	e8 2a de ff ff       	call   80493d0 <socket@plt>
 804b5a6:	85 c0                	test   %eax,%eax
 804b5a8:	89 c3                	mov    %eax,%ebx
 804b5aa:	79 24                	jns    804b5d0 <open_clientfd+0x60>
    bcopy((char *)hp->h_addr, 
	  (char *)&serveraddr.sin_addr.s_addr, hp->h_length);
    serveraddr.sin_port = htons(port);

    /* Establish a connection with the server */
    if (connect(clientfd, (SA *) &serveraddr, sizeof(serveraddr)) < 0)
 804b5ac:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
	return -1;
    return clientfd;
}
 804b5b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b5b4:	65 33 15 14 00 00 00 	xor    %gs:0x14,%edx
 804b5bb:	89 d8                	mov    %ebx,%eax
 804b5bd:	0f 85 95 00 00 00    	jne    804b658 <open_clientfd+0xe8>
 804b5c3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
 804b5c6:	8b 75 fc             	mov    -0x4(%ebp),%esi
 804b5c9:	89 ec                	mov    %ebp,%esp
 804b5cb:	5d                   	pop    %ebp
 804b5cc:	c3                   	ret    
 804b5cd:	8d 76 00             	lea    0x0(%esi),%esi

    if ((clientfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	return -1; /* check errno for cause of error */

    /* Fill in the server's IP address and port */
    if ((hp = gethostbyname(hostname)) == NULL)
 804b5d0:	89 34 24             	mov    %esi,(%esp)
 804b5d3:	e8 48 de ff ff       	call   8049420 <gethostbyname@plt>
 804b5d8:	85 c0                	test   %eax,%eax
 804b5da:	75 07                	jne    804b5e3 <open_clientfd+0x73>
 804b5dc:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
 804b5e1:	eb ce                	jmp    804b5b1 <open_clientfd+0x41>
 804b5e3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 804b5ea:	8d 75 e4             	lea    -0x1c(%ebp),%esi
 804b5ed:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 804b5f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 804b5fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

#ifdef __USE_BSD
__extern_always_inline void
__NTH (bcopy (__const void *__src, void *__dest, size_t __len))
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
 804b602:	c7 44 24 0c 0c 00 00 	movl   $0xc,0xc(%esp)
 804b609:	00 
 804b60a:	8b 50 0c             	mov    0xc(%eax),%edx
	return -2; /* check h_errno for cause of error */
    bzero((char *) &serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
 804b60d:	66 c7 45 e4 02 00    	movw   $0x2,-0x1c(%ebp)
 804b613:	89 54 24 08          	mov    %edx,0x8(%esp)
 804b617:	8b 40 10             	mov    0x10(%eax),%eax
 804b61a:	8b 00                	mov    (%eax),%eax
 804b61c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b620:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804b623:	89 04 24             	mov    %eax,(%esp)
 804b626:	e8 75 db ff ff       	call   80491a0 <__memmove_chk@plt>
    bcopy((char *)hp->h_addr, 
	  (char *)&serveraddr.sin_addr.s_addr, hp->h_length);
    serveraddr.sin_port = htons(port);
 804b62b:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax

    /* Establish a connection with the server */
    if (connect(clientfd, (SA *) &serveraddr, sizeof(serveraddr)) < 0)
 804b62f:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
 804b636:	00 
	return -2; /* check h_errno for cause of error */
    bzero((char *) &serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
    bcopy((char *)hp->h_addr, 
	  (char *)&serveraddr.sin_addr.s_addr, hp->h_length);
    serveraddr.sin_port = htons(port);
 804b637:	66 c1 c8 08          	ror    $0x8,%ax

    /* Establish a connection with the server */
    if (connect(clientfd, (SA *) &serveraddr, sizeof(serveraddr)) < 0)
 804b63b:	89 74 24 04          	mov    %esi,0x4(%esp)
	return -2; /* check h_errno for cause of error */
    bzero((char *) &serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
    bcopy((char *)hp->h_addr, 
	  (char *)&serveraddr.sin_addr.s_addr, hp->h_length);
    serveraddr.sin_port = htons(port);
 804b63f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

    /* Establish a connection with the server */
    if (connect(clientfd, (SA *) &serveraddr, sizeof(serveraddr)) < 0)
 804b643:	89 1c 24             	mov    %ebx,(%esp)
 804b646:	e8 05 de ff ff       	call   8049450 <connect@plt>
 804b64b:	85 c0                	test   %eax,%eax
 804b64d:	0f 89 5e ff ff ff    	jns    804b5b1 <open_clientfd+0x41>
 804b653:	e9 54 ff ff ff       	jmp    804b5ac <open_clientfd+0x3c>
 804b658:	90                   	nop
 804b659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return -1;
    return clientfd;
}
 804b660:	e8 2b da ff ff       	call   8049090 <__stack_chk_fail@plt>
 804b665:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b669:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b670 <Open_clientfd>:

/******************************************
 * Wrappers for the client/server helper routines 
 ******************************************/
int Open_clientfd(char *hostname, int port) 
{
 804b670:	55                   	push   %ebp
 804b671:	89 e5                	mov    %esp,%ebp
 804b673:	83 ec 28             	sub    $0x28,%esp
    int rc;

    if ((rc = open_clientfd(hostname, port)) < 0) {
 804b676:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b679:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b67d:	8b 45 08             	mov    0x8(%ebp),%eax
 804b680:	89 04 24             	mov    %eax,(%esp)
 804b683:	e8 e8 fe ff ff       	call   804b570 <open_clientfd>
 804b688:	85 c0                	test   %eax,%eax
 804b68a:	78 04                	js     804b690 <Open_clientfd+0x20>
	    unix_error("Open_clientfd Unix error");
	else        
	    dns_error("Open_clientfd DNS error");
    }
    return rc;
}
 804b68c:	c9                   	leave  
 804b68d:	c3                   	ret    
 804b68e:	66 90                	xchg   %ax,%ax
int Open_clientfd(char *hostname, int port) 
{
    int rc;

    if ((rc = open_clientfd(hostname, port)) < 0) {
	if (rc == -1)
 804b690:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b693:	90                   	nop
 804b694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b698:	74 16                	je     804b6b0 <Open_clientfd+0x40>
	    unix_error("Open_clientfd Unix error");
	else        
	    dns_error("Open_clientfd DNS error");
 804b69a:	c7 04 24 41 bf 04 08 	movl   $0x804bf41,(%esp)
 804b6a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b6a4:	e8 37 f0 ff ff       	call   804a6e0 <dns_error>
 804b6a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
    return rc;
}
 804b6ac:	c9                   	leave  
 804b6ad:	c3                   	ret    
 804b6ae:	66 90                	xchg   %ax,%ax
{
    int rc;

    if ((rc = open_clientfd(hostname, port)) < 0) {
	if (rc == -1)
	    unix_error("Open_clientfd Unix error");
 804b6b0:	c7 04 24 28 bf 04 08 	movl   $0x804bf28,(%esp)
 804b6b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b6ba:	e8 01 f2 ff ff       	call   804a8c0 <unix_error>
 804b6bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
	else        
	    dns_error("Open_clientfd DNS error");
    }
    return rc;
}
 804b6c2:	c9                   	leave  
 804b6c3:	c3                   	ret    
 804b6c4:	66 90                	xchg   %ax,%ax
 804b6c6:	66 90                	xchg   %ax,%ax
 804b6c8:	66 90                	xchg   %ax,%ax
 804b6ca:	66 90                	xchg   %ax,%ax
 804b6cc:	66 90                	xchg   %ax,%ax
 804b6ce:	66 90                	xchg   %ax,%ax

0804b6d0 <__libc_csu_init>:
 804b6d0:	55                   	push   %ebp
 804b6d1:	57                   	push   %edi
 804b6d2:	56                   	push   %esi
 804b6d3:	53                   	push   %ebx
 804b6d4:	e8 69 00 00 00       	call   804b742 <__i686.get_pc_thunk.bx>
 804b6d9:	81 c3 27 29 00 00    	add    $0x2927,%ebx
 804b6df:	83 ec 1c             	sub    $0x1c,%esp
 804b6e2:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 804b6e6:	8d bb 18 ff ff ff    	lea    -0xe8(%ebx),%edi
 804b6ec:	e8 2f d8 ff ff       	call   8048f20 <_init>
 804b6f1:	8d 83 18 ff ff ff    	lea    -0xe8(%ebx),%eax
 804b6f7:	29 c7                	sub    %eax,%edi
 804b6f9:	c1 ff 02             	sar    $0x2,%edi
 804b6fc:	85 ff                	test   %edi,%edi
 804b6fe:	74 29                	je     804b729 <__libc_csu_init+0x59>
 804b700:	31 f6                	xor    %esi,%esi
 804b702:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b708:	8b 44 24 38          	mov    0x38(%esp),%eax
 804b70c:	89 2c 24             	mov    %ebp,(%esp)
 804b70f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b713:	8b 44 24 34          	mov    0x34(%esp),%eax
 804b717:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b71b:	ff 94 b3 18 ff ff ff 	call   *-0xe8(%ebx,%esi,4)
 804b722:	83 c6 01             	add    $0x1,%esi
 804b725:	39 fe                	cmp    %edi,%esi
 804b727:	75 df                	jne    804b708 <__libc_csu_init+0x38>
 804b729:	83 c4 1c             	add    $0x1c,%esp
 804b72c:	5b                   	pop    %ebx
 804b72d:	5e                   	pop    %esi
 804b72e:	5f                   	pop    %edi
 804b72f:	5d                   	pop    %ebp
 804b730:	c3                   	ret    
 804b731:	eb 0d                	jmp    804b740 <__libc_csu_fini>
 804b733:	90                   	nop
 804b734:	90                   	nop
 804b735:	90                   	nop
 804b736:	90                   	nop
 804b737:	90                   	nop
 804b738:	90                   	nop
 804b739:	90                   	nop
 804b73a:	90                   	nop
 804b73b:	90                   	nop
 804b73c:	90                   	nop
 804b73d:	90                   	nop
 804b73e:	90                   	nop
 804b73f:	90                   	nop

0804b740 <__libc_csu_fini>:
 804b740:	f3 c3                	repz ret 

0804b742 <__i686.get_pc_thunk.bx>:
 804b742:	8b 1c 24             	mov    (%esp),%ebx
 804b745:	c3                   	ret    
 804b746:	66 90                	xchg   %ax,%ax
 804b748:	66 90                	xchg   %ax,%ax
 804b74a:	66 90                	xchg   %ax,%ax
 804b74c:	66 90                	xchg   %ax,%ax
 804b74e:	66 90                	xchg   %ax,%ax

0804b750 <__do_global_ctors_aux>:
 804b750:	55                   	push   %ebp
 804b751:	89 e5                	mov    %esp,%ebp
 804b753:	53                   	push   %ebx
 804b754:	83 ec 04             	sub    $0x4,%esp
 804b757:	a1 18 df 04 08       	mov    0x804df18,%eax
 804b75c:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b75f:	74 13                	je     804b774 <__do_global_ctors_aux+0x24>
 804b761:	bb 18 df 04 08       	mov    $0x804df18,%ebx
 804b766:	66 90                	xchg   %ax,%ax
 804b768:	83 eb 04             	sub    $0x4,%ebx
 804b76b:	ff d0                	call   *%eax
 804b76d:	8b 03                	mov    (%ebx),%eax
 804b76f:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b772:	75 f4                	jne    804b768 <__do_global_ctors_aux+0x18>
 804b774:	83 c4 04             	add    $0x4,%esp
 804b777:	5b                   	pop    %ebx
 804b778:	5d                   	pop    %ebp
 804b779:	c3                   	ret    
 804b77a:	66 90                	xchg   %ax,%ax

Disassembly of section .fini:

0804b77c <_fini>:
 804b77c:	53                   	push   %ebx
 804b77d:	83 ec 08             	sub    $0x8,%esp
 804b780:	e8 00 00 00 00       	call   804b785 <_fini+0x9>
 804b785:	5b                   	pop    %ebx
 804b786:	81 c3 7b 28 00 00    	add    $0x287b,%ebx
 804b78c:	e8 3f dd ff ff       	call   80494d0 <__do_global_dtors_aux>
 804b791:	83 c4 08             	add    $0x8,%esp
 804b794:	5b                   	pop    %ebx
 804b795:	c3                   	ret    
