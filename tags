!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Accept	csapp.c	/^int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) $/;"	f
Alarm	csapp.c	/^unsigned int Alarm(unsigned int seconds) {$/;"	f
Bind	csapp.c	/^void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) $/;"	f
CC	Makefile	/^CC		= gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS	= -O2 -Wall -g$/;"	m
CMD_JOIN	sircd.h	21;"	d
CMD_LIST	sircd.h	23;"	d
CMD_NICK	sircd.h	18;"	d
CMD_PART	sircd.h	22;"	d
CMD_PRIVMSG	sircd.h	24;"	d
CMD_QUIT	sircd.h	20;"	d
CMD_UNKNOWN	sircd.h	26;"	d
CMD_USER	sircd.h	19;"	d
CMD_WHO	sircd.h	25;"	d
Calloc	csapp.c	/^void *Calloc(size_t nmemb, size_t size) $/;"	f
Close	csapp.c	/^void Close(int fd) $/;"	f
Connect	csapp.c	/^void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) $/;"	f
DEF_MODE	csapp.h	30;"	d
DEF_UMASK	csapp.h	31;"	d
Dup2	csapp.c	/^int Dup2(int fd1, int fd2) $/;"	f
EMPTY_FD	sircd.c	21;"	d	file:
Execve	csapp.c	/^void Execve(const char *filename, char *const argv[], char *const envp[]) $/;"	f
Fclose	csapp.c	/^void Fclose(FILE *fp) $/;"	f
Fdopen	csapp.c	/^FILE *Fdopen(int fd, const char *type) $/;"	f
Fgets	csapp.c	/^char *Fgets(char *ptr, int n, FILE *stream) $/;"	f
Fopen	csapp.c	/^FILE *Fopen(const char *filename, const char *mode) $/;"	f
Fork	csapp.c	/^pid_t Fork(void) $/;"	f
Fputs	csapp.c	/^void Fputs(const char *ptr, FILE *stream) $/;"	f
Fread	csapp.c	/^size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) $/;"	f
Free	csapp.c	/^void Free(void *ptr) $/;"	f
Fstat	csapp.c	/^void Fstat(int fd, struct stat *buf) $/;"	f
Fwrite	csapp.c	/^void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) $/;"	f
Gethostbyaddr	csapp.c	/^struct hostent *Gethostbyaddr(const char *addr, int len, int type) $/;"	f
Gethostbyname	csapp.c	/^struct hostent *Gethostbyname(const char *name) $/;"	f
Getpgrp	csapp.c	/^pid_t Getpgrp(void) {$/;"	f
Kill	csapp.c	/^void Kill(pid_t pid, int signum) $/;"	f
LD	Makefile	/^LD		= gcc$/;"	m
LFLAGS	Makefile	/^LFLAGS	= -g $/;"	m
LIBS	Makefile	/^LIBS	= -lpthread$/;"	m
LISTENQ	csapp.h	57;"	d
Listen	csapp.c	/^void Listen(int s, int backlog) $/;"	f
Lseek	csapp.c	/^off_t Lseek(int fildes, off_t offset, int whence) $/;"	f
MAXBUF	csapp.h	56;"	d
MAXLINE	csapp.h	55;"	d
MAX_CONFIG_FILE_LINES	rtlib.h	17;"	d
MAX_CONFIG_FILE_LINE_LEN	rtlib.h	21;"	d
MAX_MSG_LEN	sircd.c	19;"	d	file:
MAX_MSG_TOKENS	sircd.c	18;"	d	file:
Malloc	csapp.c	/^void *Malloc(size_t size) $/;"	f
Mmap	csapp.c	/^void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) $/;"	f
Munmap	csapp.c	/^void Munmap(void *start, size_t length) $/;"	f
NAME_LENGTH	sircd.h	28;"	d
OBJECTS	Makefile	/^OBJECTS = sircd.o rtlib.o rtgrading.o csapp.o$/;"	m
Open	csapp.c	/^int Open(const char *pathname, int flags, mode_t mode) $/;"	f
Open_clientfd	csapp.c	/^int Open_clientfd(char *hostname, int port) $/;"	f
Open_listenfd	csapp.c	/^int Open_listenfd(int port) $/;"	f
P	csapp.c	/^void P(sem_t *sem) $/;"	f
Pause	csapp.c	/^void Pause() $/;"	f
Pthread_cancel	csapp.c	/^void Pthread_cancel(pthread_t tid) {$/;"	f
Pthread_create	csapp.c	/^void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, $/;"	f
Pthread_detach	csapp.c	/^void Pthread_detach(pthread_t tid) {$/;"	f
Pthread_exit	csapp.c	/^void Pthread_exit(void *retval) {$/;"	f
Pthread_join	csapp.c	/^void Pthread_join(pthread_t tid, void **thread_return) {$/;"	f
Pthread_once	csapp.c	/^void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {$/;"	f
Pthread_self	csapp.c	/^pthread_t Pthread_self(void) {$/;"	f
RIO_BUFSIZE	csapp.h	41;"	d
Read	csapp.c	/^ssize_t Read(int fd, void *buf, size_t count) $/;"	f
Realloc	csapp.c	/^void *Realloc(void *ptr, size_t size) $/;"	f
Rio_readinitb	csapp.c	/^void Rio_readinitb(rio_t *rp, int fd)$/;"	f
Rio_readlineb	csapp.c	/^ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) $/;"	f
Rio_readn	csapp.c	/^ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) $/;"	f
Rio_readnb	csapp.c	/^ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) $/;"	f
Rio_writen	csapp.c	/^void Rio_writen(int fd, void *usrbuf, size_t n) $/;"	f
SA	csapp.h	/^typedef struct sockaddr SA;$/;"	t	typeref:struct:sockaddr
SHORT_MESSAGE_LEN	sircd.c	20;"	d	file:
Select	csapp.c	/^int Select(int  n, fd_set *readfds, fd_set *writefds,$/;"	f
Sem_init	csapp.c	/^void Sem_init(sem_t *sem, int pshared, unsigned int value) $/;"	f
Setpgid	csapp.c	/^void Setpgid(pid_t pid, pid_t pgid) {$/;"	f
Setsockopt	csapp.c	/^void Setsockopt(int s, int level, int optname, const void *optval, int optlen) $/;"	f
Sigaddset	csapp.c	/^void Sigaddset(sigset_t *set, int signum)$/;"	f
Sigdelset	csapp.c	/^void Sigdelset(sigset_t *set, int signum)$/;"	f
Sigemptyset	csapp.c	/^void Sigemptyset(sigset_t *set)$/;"	f
Sigfillset	csapp.c	/^void Sigfillset(sigset_t *set)$/;"	f
Sigismember	csapp.c	/^int Sigismember(const sigset_t *set, int signum)$/;"	f
Signal	csapp.c	/^handler_t *Signal(int signum, handler_t *handler) $/;"	f
Sigprocmask	csapp.c	/^void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)$/;"	f
Sleep	csapp.c	/^unsigned int Sleep(unsigned int secs) $/;"	f
Socket	csapp.c	/^int Socket(int domain, int type, int protocol) $/;"	f
Stat	csapp.c	/^void Stat(const char *filename, struct stat *buf) $/;"	f
TARGET	Makefile	/^TARGET 	= sircd$/;"	m
V	csapp.c	/^void V(sem_t *sem) $/;"	f
VER_FULL	sircd.h	16;"	d
VER_NORMAL	sircd.h	14;"	d
VER_USER	sircd.h	15;"	d
Wait	csapp.c	/^pid_t Wait(int *status) $/;"	f
Waitpid	csapp.c	/^pid_t Waitpid(pid_t pid, int *iptr, int options) $/;"	f
Write	csapp.c	/^ssize_t Write(int fd, const void *buf, size_t count) $/;"	f
_SIRCD_H	sircd.h	12;"	d
__CSAPP_H__	csapp.h	3;"	d
__RTGRADING_H__	rtgrading.h	13;"	d
__RTLIB_H__	rtlib.h	12;"	d
_rt_optstring	rtlib.c	/^static const char* const _rt_optstring = "VSi:c:G:y:a:n:r:g:d:s:";$/;"	v	file:
add_client	sircd.c	/^void add_client(int connfd, pool* p){$/;"	f
advertisement_cycle_time	rtlib.h	/^    unsigned long advertisement_cycle_time; \/* -a advertisement cycle *\/$/;"	m	struct:rt_args_s
app_error	csapp.c	/^void app_error(char *msg) \/* application error *\/$/;"	f
channel	sircd.h	/^}channel;$/;"	t	typeref:struct:s_channel
channel_count	sircd.c	/^long channel_count;$/;"	v
channel_id	sircd.h	/^    int channel_id;                 \/\/the id of the channel where the client was in $/;"	m	struct:s_client
channel_id	sircd.h	/^    int channel_id;         \/\/the id of the channel$/;"	m	struct:s_channel
channel_name	sircd.h	/^    char channel_name[NAME_LENGTH];  \/\/the name of the channel$/;"	m	struct:s_channel
check_command	sircd.c	/^int check_command(char* msg){$/;"	f
client	sircd.h	/^}client;$/;"	t	typeref:struct:s_client
client_count	sircd.h	/^    int client_count;       \/\/the number of connected clients in this channel $/;"	m	struct:s_channel
client_pool	sircd.c	/^pool client_pool;$/;"	v
client_read_buf	sircd.h	/^    rio_t client_read_buf[FD_SETSIZE];\/\/the read buffer from which get the messages$/;"	m	struct:s_pool
clientfd	sircd.h	/^    int clientfd;                   \/\/the file descriptor of the client$/;"	m	struct:s_client
clientfd	sircd.h	/^    int clientfd[FD_SETSIZE];\/\/client descriptor list $/;"	m	struct:s_pool
clients_list	sircd.h	/^    int clients_list[FD_SETSIZE];\/\/the client descriptor of the client in this pool(not necessarily connected now)$/;"	m	struct:s_channel
config_file	rtlib.h	/^    struct rt_config_file_s config_file; \/* configuration file structure *\/$/;"	m	struct:rt_args_s	typeref:struct:rt_args_s::rt_config_file_s
connected_clients	sircd.h	/^    int connected_clients[FD_SETSIZE];\/\/whether the client with this descriptor is connected in this channel$/;"	m	struct:s_channel
curr_nodeID	sircd.c	/^u_long curr_nodeID;$/;"	v
curr_node_config_entry	sircd.c	/^rt_config_entry_t *curr_node_config_entry; \/* The config_entry for this node *\/$/;"	v
curr_node_config_file	sircd.c	/^rt_config_file_t   curr_node_config_file;  \/* The config_file  for this node *\/$/;"	v
dispatch_command	sircd.c	/^int dispatch_command(int cmd_num, char* msg, int connfd, pool* p){$/;"	f
dns_error	csapp.c	/^void dns_error(char *msg) \/* dns-style error *\/$/;"	f
dump_channel_list	sircd.c	/^void dump_channel_list(){$/;"	f
dump_client_queue	sircd.c	/^void dump_client_queue(pool* p){$/;"	f
dump_pool	sircd.c	/^void dump_pool(pool* p){$/;"	f
echo_client	sircd.c	/^void echo_client(pool* p){$/;"	f
entries	rtlib.h	/^    struct rt_config_entry_s entries[MAX_CONFIG_FILE_LINES];$/;"	m	struct:rt_config_file_s	typeref:struct:rt_config_file_s::rt_config_entry_s
get_channel_by_id	sircd.c	/^channel* get_channel_by_id(int channel_id){$/;"	f
get_channel_by_name	sircd.c	/^channel* get_channel_by_name(char *channel_name){$/;"	f
get_msg	sircd.c	/^size_t get_msg(char *buf, char *msg)$/;"	f
global_channel_list	sircd.c	/^channel* global_channel_list[FD_SETSIZE];$/;"	v
global_client_count	sircd.c	/^int global_client_count;$/;"	v
global_client_queue	sircd.c	/^client* global_client_queue[FD_SETSIZE];$/;"	v
handle_join	sircd.c	/^int handle_join(int connfd, char* channel_name){$/;"	f
handle_list	sircd.c	/^int handle_list(int connfd){$/;"	f
handle_nick	sircd.c	/^int handle_nick(int connfd, char* nickname){$/;"	f
handle_part	sircd.c	/^int handle_part(int connfd, char* names){$/;"	f
handle_privmsg	sircd.c	/^int handle_privmsg(int connfd, char* target, char* msg){$/;"	f
handle_quit	sircd.c	/^int handle_quit(int connfd, char* msg, pool* p){$/;"	f
handle_user	sircd.c	/^int handle_user(int connfd, char* username, char*  hostname, char* servername, char* realname ){$/;"	f
handle_who	sircd.c	/^int handle_who(int connfd, char* channel_name){$/;"	f
handler_t	csapp.h	/^typedef void handler_t(int);$/;"	t
hostname	sircd.h	/^    char hostname[NAME_LENGTH];$/;"	m	struct:s_client
init_client	sircd.c	/^void init_client(int connfd){$/;"	f
init_node	sircd.c	/^void init_node( int argc, char *argv[] )$/;"	f
init_pool	sircd.c	/^void init_pool(int listenfd, pool* p ){$/;"	f
ipaddr	rtlib.h	/^    unsigned long ipaddr; \/* the IP address of the node *\/$/;"	m	struct:rt_config_entry_s
irc_port	rtlib.h	/^    unsigned short irc_port; \/* the IRC and forwarding port of the IRC Serv *\/$/;"	m	struct:rt_config_entry_s
isActive	sircd.h	/^    int isActive;           \/\/whether the channel is still active$/;"	m	struct:s_channel
leave_channel	sircd.c	/^int leave_channel(int connfd, char* channel_name){$/;"	f
local_port	rtlib.h	/^    unsigned short local_port; \/* the local port of the routing daemon *\/$/;"	m	struct:rt_config_entry_s
lsa_timeout	rtlib.h	/^    unsigned long lsa_timeout;              \/* -t timeout to expire an LSA *\/$/;"	m	struct:rt_args_s
main	sircd.c	/^int main( int argc, char *argv[] )$/;"	f
max_channel_count	sircd.c	/^int max_channel_count;$/;"	v
maxfd	sircd.h	/^    int maxfd;              \/\/largest descriptor in sets$/;"	m	struct:s_pool
maxindex	sircd.h	/^    int maxindex;          \/\/max index in client array$/;"	m	struct:s_pool
neighbor_timeout	rtlib.h	/^    unsigned long neighbor_timeout;         \/* -n timeout for dead neighbors *\/$/;"	m	struct:rt_args_s
nick_is_set	sircd.h	/^    int nick_is_set;                \/\/whether the nickname is registered$/;"	m	struct:s_client
nickname	sircd.h	/^    char nickname[NAME_LENGTH];     $/;"	m	struct:s_client
nodeID	rtlib.h	/^    unsigned long nodeID; \/* nodeID of the current node *\/$/;"	m	struct:rt_args_s
nodeID	rtlib.h	/^    unsigned long nodeID; \/* the nodeID of the node *\/$/;"	m	struct:rt_config_entry_s
nready	sircd.h	/^    int nready;             \/\/return of select()$/;"	m	struct:s_pool
open_clientfd	csapp.c	/^int open_clientfd(char *hostname, int port) $/;"	f
open_listenfd	csapp.c	/^int open_listenfd(int port) $/;"	f
parse_long	rtlib.c	/^void parse_long(const char* arg, $/;"	f
pool	sircd.h	/^}pool;$/;"	t	typeref:struct:s_pool
posix_error	csapp.c	/^void posix_error(int code, char *msg) \/* posix-style error *\/$/;"	f
read_set	sircd.h	/^    fd_set read_set;        \/\/all active read descriptors$/;"	m	struct:s_pool
ready_set	sircd.h	/^    fd_set ready_set;       \/\/descriptors ready for reading$/;"	m	struct:s_pool
realname	sircd.h	/^    char realname[NAME_LENGTH];$/;"	m	struct:s_client
retransmission_timeout	rtlib.h	/^    unsigned long retransmission_timeout;   \/* -r timeout for retransmission *\/$/;"	m	struct:rt_args_s
rio_buf	csapp.h	/^    char rio_buf[RIO_BUFSIZE]; \/* internal buffer *\/$/;"	m	struct:__anon1
rio_bufptr	csapp.h	/^    char *rio_bufptr;          \/* next unread byte in internal buf *\/$/;"	m	struct:__anon1
rio_cnt	csapp.h	/^    int rio_cnt;               \/* unread bytes in internal buf *\/$/;"	m	struct:__anon1
rio_fd	csapp.h	/^    int rio_fd;                \/* descriptor for this internal buf *\/$/;"	m	struct:__anon1
rio_read	csapp.c	/^static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readinitb	csapp.c	/^void rio_readinitb(rio_t *rp, int fd) $/;"	f
rio_readlineb	csapp.c	/^ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) $/;"	f
rio_readn	csapp.c	/^ssize_t rio_readn(int fd, void *usrbuf, size_t n) $/;"	f
rio_readnb	csapp.c	/^ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) $/;"	f
rio_t	csapp.h	/^} rio_t;$/;"	t	typeref:struct:__anon1
rio_writen	csapp.c	/^ssize_t rio_writen(int fd, void *usrbuf, size_t n) $/;"	f
routing_port	rtlib.h	/^    unsigned short routing_port; \/* the routing port of the routing daemon *\/$/;"	m	struct:rt_config_entry_s
rt_args_s	rtlib.h	/^struct rt_args_s {$/;"	s
rt_args_t	rtlib.h	/^typedef struct rt_args_s rt_args_t;$/;"	t	typeref:struct:rt_args_s
rt_config_entry_s	rtlib.h	/^struct rt_config_entry_s {$/;"	s
rt_config_entry_t	rtlib.h	/^typedef struct rt_config_entry_s rt_config_entry_t;$/;"	t	typeref:struct:rt_config_entry_s
rt_config_file_s	rtlib.h	/^struct rt_config_file_s {$/;"	s
rt_config_file_t	rtlib.h	/^typedef struct rt_config_file_s rt_config_file_t;$/;"	t	typeref:struct:rt_config_file_s
rt_init	rtgrading.c	/^void rt_init(int argc, char **argv)$/;"	f
rt_parse_command_line	rtlib.c	/^void rt_parse_command_line(rt_args_t *args, int argc, char *const *argv)$/;"	f
rt_parse_config_file	rtlib.c	/^void rt_parse_config_file(const char *cmd, rt_config_file_t *config, $/;"	f
rt_recvfrom	rtgrading.c	/^int rt_recvfrom(int  s,  void  *buf,  size_t len, int flags,$/;"	f
rt_sendto	rtgrading.c	/^int rt_sendto(int s, const void *msg, size_t len, int flags,$/;"	f
s_channel	sircd.h	/^typedef struct s_channel{$/;"	s
s_client	sircd.h	/^typedef struct s_client{$/;"	s
s_pool	sircd.h	/^typedef struct s_pool{$/;"	s
servername	sircd.h	/^    char servername[NAME_LENGTH];$/;"	m	struct:s_client
size	rtlib.h	/^    int size; \/* the number of entries in the entries field *\/$/;"	m	struct:rt_config_file_s
tokenize	sircd.c	/^int tokenize( char const *in_buf, char tokens[MAX_MSG_TOKENS][MAX_MSG_LEN+1] )$/;"	f
unix_error	csapp.c	/^void unix_error(char *msg) \/* unix-style error *\/$/;"	f
user_is_set	sircd.h	/^    int user_is_set;                \/\/whether the user is registered$/;"	m	struct:s_client
username	sircd.h	/^    char username[NAME_LENGTH];$/;"	m	struct:s_client
verbosity	sircd.c	/^int verbosity;$/;"	v
write_set	sircd.h	/^    fd_set write_set;       \/\/all active write descriptors$/;"	m	struct:s_pool
